{"version":3,"file":"ForwardMessagesModal-stories.5e0a8dc4.iframe.bundle.js","mappings":";;;;AAqsEA;AANA;;AASA;AACA;;;;;AAKA;;;AAGA;AAhBA;;;AAwBA;AACA;;AAEA;AACA;;AAPA;;;AAqBA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAXA;;;;AA81BA;;;AAGA;;AAPA;;;;;;;;;;AAyjFA;AACA;AACA;;AAZA;;;AAwBA;;AAEA;AACA;AACA;AAPA;;;;AA3uFA;AACA;;AAEA;AAPA;;;;AAxPA;AACA;;;AAGA;AACA;;AAEA;AACA;;;AAZA;;AA2CA;AACA;;AC3mFA;;;ADgnFA;AACA;;AAEA;;AAXA;;;;;;;AA04FA;AACA;AACA;AACA;;AAVA;AA5nGA;AACA;AACA;AAEA;AACA;AAGA;;AAUA;AALA;AAWA;;AAMA;;AAEA;;AAEA;AAuBA;;AAhBA;;;;;;;;;;AAUA;AAGA;;AA6FA;;AAEA;;;AAJA;;AA8BA;;AAEA;;;AAJA;;AA0PA;AACA;;AAEA;;;AALA;;;;AAmEA;AACA;;AAEA;AAPA","sources":["webpack://signal-desktop/./ts/sql/Server.ts","webpack://signal-desktop/./ts/sql/util.ts"],"sourcesContent":["// Copyright 2020 Signal Messenger, LLC\n// SPDX-License-Identifier: AGPL-3.0-only\n\n/* eslint-disable camelcase */\n\nimport { mkdirSync } from 'fs';\nimport { join } from 'path';\nimport rimraf from 'rimraf';\nimport { randomBytes } from 'crypto';\nimport type { Database, Statement } from '@signalapp/better-sqlite3';\nimport SQL from '@signalapp/better-sqlite3';\nimport pProps from 'p-props';\n\nimport type { Dictionary } from 'lodash';\nimport {\n  forEach,\n  fromPairs,\n  groupBy,\n  isBoolean,\n  isNil,\n  isNumber,\n  isString,\n  last,\n  map,\n  mapValues,\n  omit,\n  pick,\n} from 'lodash';\n\nimport * as Errors from '../types/errors';\nimport { ReadStatus } from '../messages/MessageReadStatus';\nimport type { GroupV2MemberType } from '../model-types.d';\nimport type { ReactionType } from '../types/Reactions';\nimport { STORAGE_UI_KEYS } from '../types/StorageUIKeys';\nimport { UUID } from '../types/UUID';\nimport type { UUIDStringType } from '../types/UUID';\nimport type { StoredJob } from '../jobs/types';\nimport { assertDev, assertSync, strictAssert } from '../util/assert';\nimport { combineNames } from '../util/combineNames';\nimport { consoleLogger } from '../util/consoleLogger';\nimport { dropNull } from '../util/dropNull';\nimport { isNormalNumber } from '../util/isNormalNumber';\nimport { isNotNil } from '../util/isNotNil';\nimport { missingCaseError } from '../util/missingCaseError';\nimport { parseIntOrThrow } from '../util/parseIntOrThrow';\nimport * as durations from '../util/durations';\nimport { formatCountForLogging } from '../logging/formatCountForLogging';\nimport type { ConversationColorType, CustomColorType } from '../types/Colors';\nimport { RemoveAllConfiguration } from '../types/RemoveAllConfiguration';\nimport type { BadgeType, BadgeImageType } from '../badges/types';\nimport { parseBadgeCategory } from '../badges/BadgeCategory';\nimport { parseBadgeImageTheme } from '../badges/BadgeImageTheme';\nimport type { LoggerType } from '../types/Logging';\nimport * as log from '../logging/log';\nimport type {\n  EmptyQuery,\n  ArrayQuery,\n  Query,\n  JSONRows,\n  QueryFragment,\n} from './util';\nimport {\n  sqlJoin,\n  sqlFragment,\n  sql,\n  jsonToObject,\n  objectToJSON,\n  batchMultiVarQuery,\n  getCountFromTable,\n  removeById,\n  removeAllFromTable,\n  getAllFromTable,\n  getById,\n  bulkAdd,\n  createOrUpdate,\n  setUserVersion,\n  getUserVersion,\n  getSchemaVersion,\n} from './util';\nimport { updateSchema } from './migrations';\n\nimport type {\n  AdjacentMessagesByConversationOptionsType,\n  StoredAllItemsType,\n  AttachmentDownloadJobType,\n  ConversationMetricsType,\n  ConversationType,\n  DeleteSentProtoRecipientOptionsType,\n  DeleteSentProtoRecipientResultType,\n  EditedMessageType,\n  EmojiType,\n  FTSOptimizationStateType,\n  GetAllStoriesResultType,\n  GetConversationRangeCenteredOnMessageResultType,\n  GetKnownMessageAttachmentsResultType,\n  GetUnreadByConversationAndMarkReadResultType,\n  IdentityKeyIdType,\n  StoredIdentityKeyType,\n  InstalledStickerPackType,\n  ItemKeyType,\n  StoredItemType,\n  ConversationMessageStatsType,\n  MessageAttachmentsCursorType,\n  MessageMetricsType,\n  MessageType,\n  MessageTypeUnhydrated,\n  PreKeyIdType,\n  ReactionResultType,\n  StoredPreKeyType,\n  ServerSearchResultMessageType,\n  SenderKeyIdType,\n  SenderKeyType,\n  SentMessageDBType,\n  SentMessagesType,\n  SentProtoType,\n  SentProtoWithMessageIdsType,\n  SentRecipientsDBType,\n  SentRecipientsType,\n  ServerInterface,\n  SessionIdType,\n  SessionType,\n  SignedPreKeyIdType,\n  StoredSignedPreKeyType,\n  StickerPackInfoType,\n  StickerPackStatusType,\n  StickerPackType,\n  StickerType,\n  StoryDistributionMemberType,\n  StoryDistributionType,\n  StoryDistributionWithMembersType,\n  StoryReadType,\n  UninstalledStickerPackType,\n  UnprocessedType,\n  UnprocessedUpdateType,\n  GetNearbyMessageFromDeletedSetOptionsType,\n} from './Interface';\nimport { SeenStatus } from '../MessageSeenStatus';\n\ntype ConversationRow = Readonly<{\n  json: string;\n  profileLastFetchedAt: null | number;\n}>;\ntype ConversationRows = Array<ConversationRow>;\ntype StickerRow = Readonly<{\n  id: number;\n  packId: string;\n  emoji: string | null;\n  height: number;\n  isCoverOnly: number;\n  lastUsed: number;\n  path: string;\n  width: number;\n}>;\n\n// Because we can't force this module to conform to an interface, we narrow our exports\n//   to this one default export, which does conform to the interface.\n// Note: In Javascript, you need to access the .default property when requiring it\n// https://github.com/microsoft/TypeScript/issues/420\nconst dataInterface: ServerInterface = {\n  close,\n  removeDB,\n  removeIndexedDBFiles,\n\n  createOrUpdateIdentityKey,\n  getIdentityKeyById,\n  bulkAddIdentityKeys,\n  removeIdentityKeyById,\n  removeAllIdentityKeys,\n  getAllIdentityKeys,\n\n  createOrUpdatePreKey,\n  getPreKeyById,\n  bulkAddPreKeys,\n  removePreKeyById,\n  removePreKeysByUuid,\n  removeAllPreKeys,\n  getAllPreKeys,\n\n  createOrUpdateSignedPreKey,\n  getSignedPreKeyById,\n  bulkAddSignedPreKeys,\n  removeSignedPreKeyById,\n  removeSignedPreKeysByUuid,\n  removeAllSignedPreKeys,\n  getAllSignedPreKeys,\n\n  createOrUpdateItem,\n  getItemById,\n  removeItemById,\n  removeAllItems,\n  getAllItems,\n\n  createOrUpdateSenderKey,\n  getSenderKeyById,\n  removeAllSenderKeys,\n  getAllSenderKeys,\n  removeSenderKeyById,\n\n  insertSentProto,\n  deleteSentProtosOlderThan,\n  deleteSentProtoByMessageId,\n  insertProtoRecipients,\n  deleteSentProtoRecipient,\n  getSentProtoByRecipient,\n  removeAllSentProtos,\n  getAllSentProtos,\n  _getAllSentProtoRecipients,\n  _getAllSentProtoMessageIds,\n\n  createOrUpdateSession,\n  createOrUpdateSessions,\n  commitDecryptResult,\n  bulkAddSessions,\n  removeSessionById,\n  removeSessionsByConversation,\n  removeSessionsByUUID,\n  removeAllSessions,\n  getAllSessions,\n\n  eraseStorageServiceStateFromConversations,\n  getConversationCount,\n  saveConversation,\n  saveConversations,\n  getConversationById,\n  updateConversation,\n  updateConversations,\n  removeConversation,\n  _removeAllConversations,\n  updateAllConversationColors,\n  removeAllProfileKeyCredentials,\n\n  getAllConversations,\n  getAllConversationIds,\n  getAllGroupsInvolvingUuid,\n\n  searchMessages,\n  searchMessagesInConversation,\n\n  getMessageCount,\n  getStoryCount,\n  saveMessage,\n  saveMessages,\n  removeMessage,\n  removeMessages,\n  getUnreadByConversationAndMarkRead,\n  getUnreadReactionsAndMarkRead,\n  markReactionAsRead,\n  addReaction,\n  removeReactionFromConversation,\n  _getAllReactions,\n  _removeAllReactions,\n  getMessageBySender,\n  getMessageById,\n  getMessagesById,\n  _getAllMessages,\n  _getAllEditedMessages,\n  _removeAllMessages,\n  getAllMessageIds,\n  getMessagesBySentAt,\n  getUnreadEditedMessagesAndMarkRead,\n  getExpiredMessages,\n  getMessagesUnexpectedlyMissingExpirationStartTimestamp,\n  getSoonestMessageExpiry,\n  getNextTapToViewMessageTimestampToAgeOut,\n  getTapToViewMessagesNeedingErase,\n  getOlderMessagesByConversation,\n  getAllStories,\n  getNewerMessagesByConversation,\n  getTotalUnreadForConversation,\n  getMessageMetricsForConversation,\n  getConversationRangeCenteredOnMessage,\n  getConversationMessageStats,\n  getLastConversationMessage,\n  getCallHistoryMessageByCallId,\n  hasGroupCallHistoryMessage,\n  migrateConversationMessages,\n  getMessagesBetween,\n  getNearbyMessageFromDeletedSet,\n  saveEditedMessage,\n\n  getUnprocessedCount,\n  getUnprocessedByIdsAndIncrementAttempts,\n  getAllUnprocessedIds,\n  updateUnprocessedWithData,\n  updateUnprocessedsWithData,\n  getUnprocessedById,\n  removeUnprocessed,\n  removeAllUnprocessed,\n\n  getAttachmentDownloadJobById,\n  getNextAttachmentDownloadJobs,\n  saveAttachmentDownloadJob,\n  resetAttachmentDownloadPending,\n  setAttachmentDownloadJobPending,\n  removeAttachmentDownloadJob,\n  removeAllAttachmentDownloadJobs,\n\n  createOrUpdateStickerPack,\n  updateStickerPackStatus,\n  updateStickerPackInfo,\n  createOrUpdateSticker,\n  updateStickerLastUsed,\n  addStickerPackReference,\n  deleteStickerPackReference,\n  getStickerCount,\n  deleteStickerPack,\n  getAllStickerPacks,\n  addUninstalledStickerPack,\n  removeUninstalledStickerPack,\n  getInstalledStickerPacks,\n  getUninstalledStickerPacks,\n  installStickerPack,\n  uninstallStickerPack,\n  getStickerPackInfo,\n  getAllStickers,\n  getRecentStickers,\n  clearAllErrorStickerPackAttempts,\n\n  updateEmojiUsage,\n  getRecentEmojis,\n\n  getAllBadges,\n  updateOrCreateBadges,\n  badgeImageFileDownloaded,\n\n  _getAllStoryDistributions,\n  _getAllStoryDistributionMembers,\n  _deleteAllStoryDistributions,\n  createNewStoryDistribution,\n  getAllStoryDistributionsWithMembers,\n  getStoryDistributionWithMembers,\n  modifyStoryDistribution,\n  modifyStoryDistributionMembers,\n  modifyStoryDistributionWithMembers,\n  deleteStoryDistribution,\n\n  _getAllStoryReads,\n  _deleteAllStoryReads,\n  addNewStoryRead,\n  getLastStoryReadsForAuthor,\n  countStoryReadsByConversation,\n\n  removeAll,\n  removeAllConfiguration,\n\n  getMessagesNeedingUpgrade,\n  getMessagesWithVisualMediaAttachments,\n  getMessagesWithFileAttachments,\n  getMessageServerGuidsForSpam,\n\n  getJobsInQueue,\n  insertJob,\n  deleteJob,\n\n  wasGroupCallRingPreviouslyCanceled,\n  processGroupCallRingCancellation,\n  cleanExpiredGroupCallRingCancellations,\n\n  getMaxMessageCounter,\n\n  getStatisticsForLogging,\n\n  optimizeFTS,\n\n  // Server-only\n\n  initialize,\n  initializeRenderer,\n\n  getKnownMessageAttachments,\n  finishGetKnownMessageAttachments,\n  getKnownConversationAttachments,\n  removeKnownStickers,\n  removeKnownDraftAttachments,\n  getAllBadgeImageFileLocalPaths,\n};\nexport default dataInterface;\n\ntype DatabaseQueryCache = Map<string, Statement<Array<unknown>>>;\n\nconst statementCache = new WeakMap<Database, DatabaseQueryCache>();\n\nfunction prepare<T extends Array<unknown> | Record<string, unknown>>(\n  db: Database,\n  query: string,\n  { pluck = false }: { pluck?: boolean } = {}\n): Statement<T> {\n  let dbCache = statementCache.get(db);\n  if (!dbCache) {\n    dbCache = new Map();\n    statementCache.set(db, dbCache);\n  }\n\n  const cacheKey = `${pluck}:${query}`;\n  let result = dbCache.get(cacheKey) as Statement<T>;\n  if (!result) {\n    result = db.prepare<T>(query);\n    if (pluck === true) {\n      result.pluck();\n    }\n    dbCache.set(cacheKey, result);\n  }\n\n  return result;\n}\n\nfunction rowToConversation(row: ConversationRow): ConversationType {\n  const parsedJson = JSON.parse(row.json);\n\n  let profileLastFetchedAt: undefined | number;\n  if (isNormalNumber(row.profileLastFetchedAt)) {\n    profileLastFetchedAt = row.profileLastFetchedAt;\n  } else {\n    assertDev(\n      isNil(row.profileLastFetchedAt),\n      'profileLastFetchedAt contained invalid data; defaulting to undefined'\n    );\n    profileLastFetchedAt = undefined;\n  }\n\n  return {\n    ...parsedJson,\n    profileLastFetchedAt,\n  };\n}\nfunction rowToSticker(row: StickerRow): StickerType {\n  return {\n    ...row,\n    isCoverOnly: Boolean(row.isCoverOnly),\n    emoji: dropNull(row.emoji),\n  };\n}\n\nfunction isRenderer() {\n  if (typeof process === 'undefined' || !process) {\n    return true;\n  }\n\n  return process.type === 'renderer';\n}\n\nfunction keyDatabase(db: Database, key: string): void {\n  // https://www.zetetic.net/sqlcipher/sqlcipher-api/#key\n  db.pragma(`key = \"x'${key}'\"`);\n}\n\nfunction switchToWAL(db: Database): void {\n  // https://sqlite.org/wal.html\n  db.pragma('journal_mode = WAL');\n  db.pragma('synchronous = FULL');\n}\n\nfunction migrateSchemaVersion(db: Database): void {\n  const userVersion = getUserVersion(db);\n  if (userVersion > 0) {\n    return;\n  }\n\n  const schemaVersion = getSchemaVersion(db);\n  const newUserVersion = schemaVersion > 18 ? 16 : schemaVersion;\n  logger.info(\n    'migrateSchemaVersion: Migrating from schema_version ' +\n      `${schemaVersion} to user_version ${newUserVersion}`\n  );\n\n  setUserVersion(db, newUserVersion);\n}\n\nfunction openAndMigrateDatabase(filePath: string, key: string) {\n  let db: Database | undefined;\n\n  // First, we try to open the database without any cipher changes\n  try {\n    db = new SQL(filePath);\n    keyDatabase(db, key);\n    switchToWAL(db);\n    migrateSchemaVersion(db);\n\n    return db;\n  } catch (error) {\n    if (db) {\n      db.close();\n    }\n    logger.info('migrateDatabase: Migration without cipher change failed');\n  }\n\n  // If that fails, we try to open the database with 3.x compatibility to extract the\n  //   user_version (previously stored in schema_version, blown away by cipher_migrate).\n  db = new SQL(filePath);\n  keyDatabase(db, key);\n\n  // https://www.zetetic.net/blog/2018/11/30/sqlcipher-400-release/#compatability-sqlcipher-4-0-0\n  db.pragma('cipher_compatibility = 3');\n  migrateSchemaVersion(db);\n  db.close();\n\n  // After migrating user_version -> schema_version, we reopen database, because we can't\n  //   migrate to the latest ciphers after we've modified the defaults.\n  db = new SQL(filePath);\n  keyDatabase(db, key);\n\n  db.pragma('cipher_migrate');\n  switchToWAL(db);\n\n  return db;\n}\n\nconst INVALID_KEY = /[^0-9A-Fa-f]/;\nfunction openAndSetUpSQLCipher(filePath: string, { key }: { key: string }) {\n  const match = INVALID_KEY.exec(key);\n  if (match) {\n    throw new Error(`setupSQLCipher: key '${key}' is not valid`);\n  }\n\n  const db = openAndMigrateDatabase(filePath, key);\n\n  // Because foreign key support is not enabled by default!\n  db.pragma('foreign_keys = ON');\n\n  return db;\n}\n\nlet globalInstance: Database | undefined;\nlet logger = consoleLogger;\nlet globalInstanceRenderer: Database | undefined;\nlet databaseFilePath: string | undefined;\nlet indexedDBPath: string | undefined;\n\nSQL.setLogHandler((code, value) => {\n  logger.warn(`Database log code=${code}: ${value}`);\n});\n\nasync function initialize({\n  configDir,\n  key,\n  logger: suppliedLogger,\n}: {\n  configDir: string;\n  key: string;\n  logger: LoggerType;\n}): Promise<void> {\n  if (globalInstance) {\n    throw new Error('Cannot initialize more than once!');\n  }\n\n  if (!isString(configDir)) {\n    throw new Error('initialize: configDir is required!');\n  }\n  if (!isString(key)) {\n    throw new Error('initialize: key is required!');\n  }\n\n  logger = suppliedLogger;\n\n  indexedDBPath = join(configDir, 'IndexedDB');\n\n  const dbDir = join(configDir, 'sql');\n  mkdirSync(dbDir, { recursive: true });\n\n  databaseFilePath = join(dbDir, 'db.sqlite');\n\n  let db: Database | undefined;\n\n  try {\n    db = openAndSetUpSQLCipher(databaseFilePath, { key });\n\n    // For profiling use:\n    // db.pragma('cipher_profile=\\'sqlcipher.log\\'');\n\n    updateSchema(db, logger);\n\n    // At this point we can allow general access to the database\n    globalInstance = db;\n\n    // test database\n    getMessageCountSync();\n  } catch (error) {\n    logger.error('Database startup error:', error.stack);\n    if (db) {\n      db.close();\n    }\n    throw error;\n  }\n}\n\nasync function initializeRenderer({\n  configDir,\n  key,\n}: {\n  configDir: string;\n  key: string;\n}): Promise<void> {\n  if (!isRenderer()) {\n    throw new Error('Cannot call from main process.');\n  }\n  if (globalInstanceRenderer) {\n    throw new Error('Cannot initialize more than once!');\n  }\n  if (!isString(configDir)) {\n    throw new Error('initialize: configDir is required!');\n  }\n  if (!isString(key)) {\n    throw new Error('initialize: key is required!');\n  }\n\n  if (!indexedDBPath) {\n    indexedDBPath = join(configDir, 'IndexedDB');\n  }\n\n  const dbDir = join(configDir, 'sql');\n\n  if (!databaseFilePath) {\n    databaseFilePath = join(dbDir, 'db.sqlite');\n  }\n\n  let promisified: Database | undefined;\n\n  try {\n    promisified = openAndSetUpSQLCipher(databaseFilePath, { key });\n\n    // At this point we can allow general access to the database\n    globalInstanceRenderer = promisified;\n\n    // test database\n    getMessageCountSync();\n  } catch (error) {\n    log.error('Database startup error:', error.stack);\n    throw error;\n  }\n}\n\nasync function close(): Promise<void> {\n  for (const dbRef of [globalInstanceRenderer, globalInstance]) {\n    // SQLLite documentation suggests that we run `PRAGMA optimize` right\n    // before closing the database connection.\n    dbRef?.pragma('optimize');\n\n    dbRef?.close();\n  }\n\n  globalInstance = undefined;\n  globalInstanceRenderer = undefined;\n}\n\nasync function removeDB(): Promise<void> {\n  if (globalInstance) {\n    try {\n      globalInstance.close();\n    } catch (error) {\n      logger.error('removeDB: Failed to close database:', error.stack);\n    }\n    globalInstance = undefined;\n  }\n  if (!databaseFilePath) {\n    throw new Error(\n      'removeDB: Cannot erase database without a databaseFilePath!'\n    );\n  }\n\n  logger.warn('removeDB: Removing all database files');\n  rimraf.sync(databaseFilePath);\n  rimraf.sync(`${databaseFilePath}-shm`);\n  rimraf.sync(`${databaseFilePath}-wal`);\n}\n\nasync function removeIndexedDBFiles(): Promise<void> {\n  if (!indexedDBPath) {\n    throw new Error(\n      'removeIndexedDBFiles: Need to initialize and set indexedDBPath first!'\n    );\n  }\n\n  const pattern = join(indexedDBPath, '*.leveldb');\n  rimraf.sync(pattern);\n  indexedDBPath = undefined;\n}\n\nfunction getInstance(): Database {\n  if (isRenderer()) {\n    if (!globalInstanceRenderer) {\n      throw new Error('getInstance: globalInstanceRenderer not set!');\n    }\n    return globalInstanceRenderer;\n  }\n\n  if (!globalInstance) {\n    throw new Error('getInstance: globalInstance not set!');\n  }\n\n  return globalInstance;\n}\n\nconst IDENTITY_KEYS_TABLE = 'identityKeys';\nasync function createOrUpdateIdentityKey(\n  data: StoredIdentityKeyType\n): Promise<void> {\n  return createOrUpdate(getInstance(), IDENTITY_KEYS_TABLE, data);\n}\nasync function getIdentityKeyById(\n  id: IdentityKeyIdType\n): Promise<StoredIdentityKeyType | undefined> {\n  return getById(getInstance(), IDENTITY_KEYS_TABLE, id);\n}\nasync function bulkAddIdentityKeys(\n  array: Array<StoredIdentityKeyType>\n): Promise<void> {\n  return bulkAdd(getInstance(), IDENTITY_KEYS_TABLE, array);\n}\nasync function removeIdentityKeyById(id: IdentityKeyIdType): Promise<void> {\n  return removeById(getInstance(), IDENTITY_KEYS_TABLE, id);\n}\nasync function removeAllIdentityKeys(): Promise<void> {\n  return removeAllFromTable(getInstance(), IDENTITY_KEYS_TABLE);\n}\nasync function getAllIdentityKeys(): Promise<Array<StoredIdentityKeyType>> {\n  return getAllFromTable(getInstance(), IDENTITY_KEYS_TABLE);\n}\n\nconst PRE_KEYS_TABLE = 'preKeys';\nasync function createOrUpdatePreKey(data: StoredPreKeyType): Promise<void> {\n  return createOrUpdate(getInstance(), PRE_KEYS_TABLE, data);\n}\nasync function getPreKeyById(\n  id: PreKeyIdType\n): Promise<StoredPreKeyType | undefined> {\n  return getById(getInstance(), PRE_KEYS_TABLE, id);\n}\nasync function bulkAddPreKeys(array: Array<StoredPreKeyType>): Promise<void> {\n  return bulkAdd(getInstance(), PRE_KEYS_TABLE, array);\n}\nasync function removePreKeyById(id: PreKeyIdType): Promise<void> {\n  return removeById(getInstance(), PRE_KEYS_TABLE, id);\n}\nasync function removePreKeysByUuid(uuid: UUIDStringType): Promise<void> {\n  const db = getInstance();\n  db.prepare<Query>('DELETE FROM preKeys WHERE ourUuid IS $uuid;').run({\n    uuid,\n  });\n}\nasync function removeAllPreKeys(): Promise<void> {\n  return removeAllFromTable(getInstance(), PRE_KEYS_TABLE);\n}\nasync function getAllPreKeys(): Promise<Array<StoredPreKeyType>> {\n  return getAllFromTable(getInstance(), PRE_KEYS_TABLE);\n}\n\nconst SIGNED_PRE_KEYS_TABLE = 'signedPreKeys';\nasync function createOrUpdateSignedPreKey(\n  data: StoredSignedPreKeyType\n): Promise<void> {\n  return createOrUpdate(getInstance(), SIGNED_PRE_KEYS_TABLE, data);\n}\nasync function getSignedPreKeyById(\n  id: SignedPreKeyIdType\n): Promise<StoredSignedPreKeyType | undefined> {\n  return getById(getInstance(), SIGNED_PRE_KEYS_TABLE, id);\n}\nasync function bulkAddSignedPreKeys(\n  array: Array<StoredSignedPreKeyType>\n): Promise<void> {\n  return bulkAdd(getInstance(), SIGNED_PRE_KEYS_TABLE, array);\n}\nasync function removeSignedPreKeyById(id: SignedPreKeyIdType): Promise<void> {\n  return removeById(getInstance(), SIGNED_PRE_KEYS_TABLE, id);\n}\nasync function removeSignedPreKeysByUuid(uuid: UUIDStringType): Promise<void> {\n  const db = getInstance();\n  db.prepare<Query>('DELETE FROM signedPreKeys WHERE ourUuid IS $uuid;').run({\n    uuid,\n  });\n}\nasync function removeAllSignedPreKeys(): Promise<void> {\n  return removeAllFromTable(getInstance(), SIGNED_PRE_KEYS_TABLE);\n}\nasync function getAllSignedPreKeys(): Promise<Array<StoredSignedPreKeyType>> {\n  const db = getInstance();\n  const rows: JSONRows = db\n    .prepare<EmptyQuery>(\n      `\n      SELECT json\n      FROM signedPreKeys\n      ORDER BY id ASC;\n      `\n    )\n    .all();\n\n  return rows.map(row => jsonToObject(row.json));\n}\n\nconst ITEMS_TABLE = 'items';\nasync function createOrUpdateItem<K extends ItemKeyType>(\n  data: StoredItemType<K>\n): Promise<void> {\n  return createOrUpdate(getInstance(), ITEMS_TABLE, data);\n}\nasync function getItemById<K extends ItemKeyType>(\n  id: K\n): Promise<StoredItemType<K> | undefined> {\n  return getById(getInstance(), ITEMS_TABLE, id);\n}\nasync function getAllItems(): Promise<StoredAllItemsType> {\n  const db = getInstance();\n  const rows: JSONRows = db\n    .prepare<EmptyQuery>('SELECT json FROM items ORDER BY id ASC;')\n    .all();\n\n  type RawItemType = { id: ItemKeyType; value: unknown };\n\n  const items = rows.map(row => jsonToObject<RawItemType>(row.json));\n\n  const result: Record<ItemKeyType, unknown> = Object.create(null);\n\n  for (const { id, value } of items) {\n    result[id] = value;\n  }\n\n  return result as unknown as StoredAllItemsType;\n}\nasync function removeItemById(id: ItemKeyType): Promise<void> {\n  return removeById(getInstance(), ITEMS_TABLE, id);\n}\nasync function removeAllItems(): Promise<void> {\n  return removeAllFromTable(getInstance(), ITEMS_TABLE);\n}\n\nasync function createOrUpdateSenderKey(key: SenderKeyType): Promise<void> {\n  createOrUpdateSenderKeySync(key);\n}\n\nfunction createOrUpdateSenderKeySync(key: SenderKeyType): void {\n  const db = getInstance();\n\n  prepare(\n    db,\n    `\n    INSERT OR REPLACE INTO senderKeys (\n      id,\n      senderId,\n      distributionId,\n      data,\n      lastUpdatedDate\n    ) values (\n      $id,\n      $senderId,\n      $distributionId,\n      $data,\n      $lastUpdatedDate\n    )\n    `\n  ).run(key);\n}\nasync function getSenderKeyById(\n  id: SenderKeyIdType\n): Promise<SenderKeyType | undefined> {\n  const db = getInstance();\n  const row = prepare(db, 'SELECT * FROM senderKeys WHERE id = $id').get({\n    id,\n  });\n\n  return row;\n}\nasync function removeAllSenderKeys(): Promise<void> {\n  const db = getInstance();\n  prepare<EmptyQuery>(db, 'DELETE FROM senderKeys').run();\n}\nasync function getAllSenderKeys(): Promise<Array<SenderKeyType>> {\n  const db = getInstance();\n  const rows = prepare<EmptyQuery>(db, 'SELECT * FROM senderKeys').all();\n\n  return rows;\n}\nasync function removeSenderKeyById(id: SenderKeyIdType): Promise<void> {\n  const db = getInstance();\n  prepare(db, 'DELETE FROM senderKeys WHERE id = $id').run({ id });\n}\n\nasync function insertSentProto(\n  proto: SentProtoType,\n  options: {\n    recipients: SentRecipientsType;\n    messageIds: SentMessagesType;\n  }\n): Promise<number> {\n  const db = getInstance();\n  const { recipients, messageIds } = options;\n\n  // Note: we use `pluck` in this function to fetch only the first column of returned row.\n\n  return db.transaction(() => {\n    // 1. Insert the payload, fetching its primary key id\n    const info = prepare(\n      db,\n      `\n      INSERT INTO sendLogPayloads (\n        contentHint,\n        proto,\n        timestamp,\n        urgent,\n        hasPniSignatureMessage\n      ) VALUES (\n        $contentHint,\n        $proto,\n        $timestamp,\n        $urgent,\n        $hasPniSignatureMessage\n      );\n      `\n    ).run({\n      ...proto,\n      urgent: proto.urgent ? 1 : 0,\n      hasPniSignatureMessage: proto.hasPniSignatureMessage ? 1 : 0,\n    });\n    const id = parseIntOrThrow(\n      info.lastInsertRowid,\n      'insertSentProto/lastInsertRowid'\n    );\n\n    // 2. Insert a record for each recipient device.\n    const recipientStatement = prepare(\n      db,\n      `\n      INSERT INTO sendLogRecipients (\n        payloadId,\n        recipientUuid,\n        deviceId\n      ) VALUES (\n        $id,\n        $recipientUuid,\n        $deviceId\n      );\n      `\n    );\n\n    const recipientUuids = Object.keys(recipients);\n    for (const recipientUuid of recipientUuids) {\n      const deviceIds = recipients[recipientUuid];\n\n      for (const deviceId of deviceIds) {\n        recipientStatement.run({\n          id,\n          recipientUuid,\n          deviceId,\n        });\n      }\n    }\n\n    // 2. Insert a record for each message referenced by this payload.\n    const messageStatement = prepare(\n      db,\n      `\n      INSERT INTO sendLogMessageIds (\n        payloadId,\n        messageId\n      ) VALUES (\n        $id,\n        $messageId\n      );\n      `\n    );\n\n    for (const messageId of new Set(messageIds)) {\n      messageStatement.run({\n        id,\n        messageId,\n      });\n    }\n\n    return id;\n  })();\n}\n\nasync function deleteSentProtosOlderThan(timestamp: number): Promise<void> {\n  const db = getInstance();\n\n  prepare(\n    db,\n    `\n    DELETE FROM sendLogPayloads\n    WHERE\n      timestamp IS NULL OR\n      timestamp < $timestamp;\n    `\n  ).run({\n    timestamp,\n  });\n}\n\nasync function deleteSentProtoByMessageId(messageId: string): Promise<void> {\n  const db = getInstance();\n\n  prepare(\n    db,\n    `\n    DELETE FROM sendLogPayloads WHERE id IN (\n      SELECT payloadId FROM sendLogMessageIds\n      WHERE messageId = $messageId\n    );\n    `\n  ).run({\n    messageId,\n  });\n}\n\nasync function insertProtoRecipients({\n  id,\n  recipientUuid,\n  deviceIds,\n}: {\n  id: number;\n  recipientUuid: string;\n  deviceIds: Array<number>;\n}): Promise<void> {\n  const db = getInstance();\n\n  db.transaction(() => {\n    const statement = prepare(\n      db,\n      `\n      INSERT INTO sendLogRecipients (\n        payloadId,\n        recipientUuid,\n        deviceId\n      ) VALUES (\n        $id,\n        $recipientUuid,\n        $deviceId\n      );\n      `\n    );\n\n    for (const deviceId of deviceIds) {\n      statement.run({\n        id,\n        recipientUuid,\n        deviceId,\n      });\n    }\n  })();\n}\n\nasync function deleteSentProtoRecipient(\n  options:\n    | DeleteSentProtoRecipientOptionsType\n    | ReadonlyArray<DeleteSentProtoRecipientOptionsType>\n): Promise<DeleteSentProtoRecipientResultType> {\n  const db = getInstance();\n\n  const items = Array.isArray(options) ? options : [options];\n\n  // Note: we use `pluck` in this function to fetch only the first column of\n  // returned row.\n\n  return db.transaction(() => {\n    const successfulPhoneNumberShares = new Array<string>();\n\n    for (const item of items) {\n      const { timestamp, recipientUuid, deviceId } = item;\n\n      // 1. Figure out what payload we're talking about.\n      const rows = prepare(\n        db,\n        `\n        SELECT sendLogPayloads.id, sendLogPayloads.hasPniSignatureMessage\n        FROM sendLogPayloads\n        INNER JOIN sendLogRecipients\n          ON sendLogRecipients.payloadId = sendLogPayloads.id\n        WHERE\n          sendLogPayloads.timestamp = $timestamp AND\n          sendLogRecipients.recipientUuid = $recipientUuid AND\n          sendLogRecipients.deviceId = $deviceId;\n       `\n      ).all({ timestamp, recipientUuid, deviceId });\n      if (!rows.length) {\n        continue;\n      }\n      if (rows.length > 1) {\n        logger.warn(\n          'deleteSentProtoRecipient: More than one payload matches ' +\n            `recipient and timestamp ${timestamp}. Using the first.`\n        );\n      }\n\n      const { id, hasPniSignatureMessage } = rows[0];\n\n      // 2. Delete the recipient/device combination in question.\n      prepare(\n        db,\n        `\n        DELETE FROM sendLogRecipients\n        WHERE\n          payloadId = $id AND\n          recipientUuid = $recipientUuid AND\n          deviceId = $deviceId;\n        `\n      ).run({ id, recipientUuid, deviceId });\n\n      // 3. See how many more recipient devices there were for this payload.\n      const remainingDevices = prepare(\n        db,\n        `\n        SELECT count(1) FROM sendLogRecipients\n        WHERE payloadId = $id AND recipientUuid = $recipientUuid;\n        `,\n        { pluck: true }\n      ).get({ id, recipientUuid });\n\n      // 4. If there are no remaining devices for this recipient and we included\n      //    the pni signature in the proto - return the recipient to the caller.\n      if (remainingDevices === 0 && hasPniSignatureMessage) {\n        logger.info(\n          'deleteSentProtoRecipient: ' +\n            `Successfully shared phone number with ${recipientUuid} ` +\n            `through message ${timestamp}`\n        );\n        successfulPhoneNumberShares.push(recipientUuid);\n      }\n\n      strictAssert(\n        isNumber(remainingDevices),\n        'deleteSentProtoRecipient: select count() returned non-number!'\n      );\n\n      // 5. See how many more recipients there were for this payload.\n      const remainingTotal = prepare(\n        db,\n        'SELECT count(1) FROM sendLogRecipients WHERE payloadId = $id;',\n        { pluck: true }\n      ).get({ id });\n\n      strictAssert(\n        isNumber(remainingTotal),\n        'deleteSentProtoRecipient: select count() returned non-number!'\n      );\n\n      if (remainingTotal > 0) {\n        continue;\n      }\n\n      // 6. Delete the entire payload if there are no more recipients left.\n      logger.info(\n        'deleteSentProtoRecipient: ' +\n          `Deleting proto payload for timestamp ${timestamp}`\n      );\n\n      prepare(db, 'DELETE FROM sendLogPayloads WHERE id = $id;').run({\n        id,\n      });\n    }\n\n    return { successfulPhoneNumberShares };\n  })();\n}\n\nasync function getSentProtoByRecipient({\n  now,\n  recipientUuid,\n  timestamp,\n}: {\n  now: number;\n  recipientUuid: string;\n  timestamp: number;\n}): Promise<SentProtoWithMessageIdsType | undefined> {\n  const db = getInstance();\n\n  const HOUR = 1000 * 60 * 60;\n  const oneDayAgo = now - HOUR * 24;\n\n  await deleteSentProtosOlderThan(oneDayAgo);\n\n  const row = prepare(\n    db,\n    `\n    SELECT\n      sendLogPayloads.*,\n      GROUP_CONCAT(DISTINCT sendLogMessageIds.messageId) AS messageIds\n    FROM sendLogPayloads\n    INNER JOIN sendLogRecipients ON sendLogRecipients.payloadId = sendLogPayloads.id\n    LEFT JOIN sendLogMessageIds ON sendLogMessageIds.payloadId = sendLogPayloads.id\n    WHERE\n      sendLogPayloads.timestamp = $timestamp AND\n      sendLogRecipients.recipientUuid = $recipientUuid\n    GROUP BY sendLogPayloads.id;\n    `\n  ).get({\n    timestamp,\n    recipientUuid,\n  });\n\n  if (!row) {\n    return undefined;\n  }\n\n  const { messageIds } = row;\n  return {\n    ...row,\n    urgent: isNumber(row.urgent) ? Boolean(row.urgent) : true,\n    hasPniSignatureMessage: isNumber(row.hasPniSignatureMessage)\n      ? Boolean(row.hasPniSignatureMessage)\n      : true,\n    messageIds: messageIds ? messageIds.split(',') : [],\n  };\n}\nasync function removeAllSentProtos(): Promise<void> {\n  const db = getInstance();\n  prepare<EmptyQuery>(db, 'DELETE FROM sendLogPayloads;').run();\n}\nasync function getAllSentProtos(): Promise<Array<SentProtoType>> {\n  const db = getInstance();\n  const rows = prepare<EmptyQuery>(db, 'SELECT * FROM sendLogPayloads;').all();\n\n  return rows.map(row => ({\n    ...row,\n    urgent: isNumber(row.urgent) ? Boolean(row.urgent) : true,\n    hasPniSignatureMessage: isNumber(row.hasPniSignatureMessage)\n      ? Boolean(row.hasPniSignatureMessage)\n      : true,\n  }));\n}\nasync function _getAllSentProtoRecipients(): Promise<\n  Array<SentRecipientsDBType>\n> {\n  const db = getInstance();\n  const rows = prepare<EmptyQuery>(\n    db,\n    'SELECT * FROM sendLogRecipients;'\n  ).all();\n\n  return rows;\n}\nasync function _getAllSentProtoMessageIds(): Promise<Array<SentMessageDBType>> {\n  const db = getInstance();\n  const rows = prepare<EmptyQuery>(\n    db,\n    'SELECT * FROM sendLogMessageIds;'\n  ).all();\n\n  return rows;\n}\n\nconst SESSIONS_TABLE = 'sessions';\nfunction createOrUpdateSessionSync(data: SessionType): void {\n  const db = getInstance();\n  const { id, conversationId, ourUuid, uuid } = data;\n  if (!id) {\n    throw new Error(\n      'createOrUpdateSession: Provided data did not have a truthy id'\n    );\n  }\n  if (!conversationId) {\n    throw new Error(\n      'createOrUpdateSession: Provided data did not have a truthy conversationId'\n    );\n  }\n\n  prepare(\n    db,\n    `\n    INSERT OR REPLACE INTO sessions (\n      id,\n      conversationId,\n      ourUuid,\n      uuid,\n      json\n    ) values (\n      $id,\n      $conversationId,\n      $ourUuid,\n      $uuid,\n      $json\n    )\n    `\n  ).run({\n    id,\n    conversationId,\n    ourUuid,\n    uuid,\n    json: objectToJSON(data),\n  });\n}\nasync function createOrUpdateSession(data: SessionType): Promise<void> {\n  return createOrUpdateSessionSync(data);\n}\n\nasync function createOrUpdateSessions(\n  array: Array<SessionType>\n): Promise<void> {\n  const db = getInstance();\n\n  db.transaction(() => {\n    for (const item of array) {\n      assertSync(createOrUpdateSessionSync(item));\n    }\n  })();\n}\n\nasync function commitDecryptResult({\n  senderKeys,\n  sessions,\n  unprocessed,\n}: {\n  senderKeys: Array<SenderKeyType>;\n  sessions: Array<SessionType>;\n  unprocessed: Array<UnprocessedType>;\n}): Promise<void> {\n  const db = getInstance();\n\n  db.transaction(() => {\n    for (const item of senderKeys) {\n      assertSync(createOrUpdateSenderKeySync(item));\n    }\n\n    for (const item of sessions) {\n      assertSync(createOrUpdateSessionSync(item));\n    }\n\n    for (const item of unprocessed) {\n      assertSync(saveUnprocessedSync(item));\n    }\n  })();\n}\n\nasync function bulkAddSessions(array: Array<SessionType>): Promise<void> {\n  return bulkAdd(getInstance(), SESSIONS_TABLE, array);\n}\nasync function removeSessionById(id: SessionIdType): Promise<void> {\n  return removeById(getInstance(), SESSIONS_TABLE, id);\n}\nasync function removeSessionsByConversation(\n  conversationId: string\n): Promise<void> {\n  const db = getInstance();\n  db.prepare<Query>(\n    `\n    DELETE FROM sessions\n    WHERE conversationId = $conversationId;\n    `\n  ).run({\n    conversationId,\n  });\n}\nasync function removeSessionsByUUID(uuid: UUIDStringType): Promise<void> {\n  const db = getInstance();\n  db.prepare<Query>(\n    `\n    DELETE FROM sessions\n    WHERE uuid = $uuid;\n    `\n  ).run({\n    uuid,\n  });\n}\nasync function removeAllSessions(): Promise<void> {\n  return removeAllFromTable(getInstance(), SESSIONS_TABLE);\n}\nasync function getAllSessions(): Promise<Array<SessionType>> {\n  return getAllFromTable(getInstance(), SESSIONS_TABLE);\n}\n// Conversations\n\nasync function getConversationCount(): Promise<number> {\n  return getCountFromTable(getInstance(), 'conversations');\n}\n\nfunction getConversationMembersList({ members, membersV2 }: ConversationType) {\n  if (membersV2) {\n    return membersV2.map((item: GroupV2MemberType) => item.uuid).join(' ');\n  }\n  if (members) {\n    return members.join(' ');\n  }\n  return null;\n}\n\nfunction saveConversationSync(\n  data: ConversationType,\n  db = getInstance()\n): void {\n  const {\n    active_at,\n    e164,\n    groupId,\n    id,\n    name,\n    profileFamilyName,\n    profileName,\n    profileLastFetchedAt,\n    type,\n    uuid,\n  } = data;\n\n  const membersList = getConversationMembersList(data);\n\n  db.prepare<Query>(\n    `\n    INSERT INTO conversations (\n      id,\n      json,\n\n      e164,\n      uuid,\n      groupId,\n\n      active_at,\n      type,\n      members,\n      name,\n      profileName,\n      profileFamilyName,\n      profileFullName,\n      profileLastFetchedAt\n    ) values (\n      $id,\n      $json,\n\n      $e164,\n      $uuid,\n      $groupId,\n\n      $active_at,\n      $type,\n      $members,\n      $name,\n      $profileName,\n      $profileFamilyName,\n      $profileFullName,\n      $profileLastFetchedAt\n    );\n    `\n  ).run({\n    id,\n    json: objectToJSON(\n      omit(data, ['profileLastFetchedAt', 'unblurredAvatarPath'])\n    ),\n\n    e164: e164 || null,\n    uuid: uuid || null,\n    groupId: groupId || null,\n\n    active_at: active_at || null,\n    type,\n    members: membersList,\n    name: name || null,\n    profileName: profileName || null,\n    profileFamilyName: profileFamilyName || null,\n    profileFullName: combineNames(profileName, profileFamilyName) || null,\n    profileLastFetchedAt: profileLastFetchedAt || null,\n  });\n}\n\nasync function saveConversation(\n  data: ConversationType,\n  db = getInstance()\n): Promise<void> {\n  return saveConversationSync(data, db);\n}\n\nasync function saveConversations(\n  arrayOfConversations: Array<ConversationType>\n): Promise<void> {\n  const db = getInstance();\n\n  db.transaction(() => {\n    for (const conversation of arrayOfConversations) {\n      assertSync(saveConversationSync(conversation));\n    }\n  })();\n}\n\nfunction updateConversationSync(\n  data: ConversationType,\n  db = getInstance()\n): void {\n  const {\n    id,\n    active_at,\n    type,\n    name,\n    profileName,\n    profileFamilyName,\n    profileLastFetchedAt,\n    e164,\n    uuid,\n  } = data;\n\n  const membersList = getConversationMembersList(data);\n\n  db.prepare(\n    `\n    UPDATE conversations SET\n      json = $json,\n\n      e164 = $e164,\n      uuid = $uuid,\n\n      active_at = $active_at,\n      type = $type,\n      members = $members,\n      name = $name,\n      profileName = $profileName,\n      profileFamilyName = $profileFamilyName,\n      profileFullName = $profileFullName,\n      profileLastFetchedAt = $profileLastFetchedAt\n    WHERE id = $id;\n    `\n  ).run({\n    id,\n    json: objectToJSON(\n      omit(data, ['profileLastFetchedAt', 'unblurredAvatarPath'])\n    ),\n\n    e164: e164 || null,\n    uuid: uuid || null,\n\n    active_at: active_at || null,\n    type,\n    members: membersList,\n    name: name || null,\n    profileName: profileName || null,\n    profileFamilyName: profileFamilyName || null,\n    profileFullName: combineNames(profileName, profileFamilyName) || null,\n    profileLastFetchedAt: profileLastFetchedAt || null,\n  });\n}\n\nasync function updateConversation(data: ConversationType): Promise<void> {\n  return updateConversationSync(data);\n}\n\nasync function updateConversations(\n  array: Array<ConversationType>\n): Promise<void> {\n  const db = getInstance();\n\n  db.transaction(() => {\n    for (const item of array) {\n      assertSync(updateConversationSync(item));\n    }\n  })();\n}\n\nfunction removeConversationsSync(ids: ReadonlyArray<string>): void {\n  const db = getInstance();\n\n  // Our node interface doesn't seem to allow you to replace one single ? with an array\n  db.prepare<ArrayQuery>(\n    `\n    DELETE FROM conversations\n    WHERE id IN ( ${ids.map(() => '?').join(', ')} );\n    `\n  ).run(ids);\n}\n\nasync function removeConversation(id: Array<string> | string): Promise<void> {\n  const db = getInstance();\n\n  if (!Array.isArray(id)) {\n    db.prepare<Query>('DELETE FROM conversations WHERE id = $id;').run({\n      id,\n    });\n\n    return;\n  }\n\n  if (!id.length) {\n    throw new Error('removeConversation: No ids to delete!');\n  }\n\n  batchMultiVarQuery(db, id, removeConversationsSync);\n}\n\nasync function _removeAllConversations(): Promise<void> {\n  const db = getInstance();\n  db.prepare<EmptyQuery>('DELETE from conversations;').run();\n}\n\nasync function getConversationById(\n  id: string\n): Promise<ConversationType | undefined> {\n  const db = getInstance();\n  const row: { json: string } = db\n    .prepare<Query>('SELECT json FROM conversations WHERE id = $id;')\n    .get({ id });\n\n  if (!row) {\n    return undefined;\n  }\n\n  return jsonToObject(row.json);\n}\n\nasync function eraseStorageServiceStateFromConversations(): Promise<void> {\n  const db = getInstance();\n\n  db.prepare<EmptyQuery>(\n    `\n    UPDATE conversations\n    SET\n      json = json_remove(json, '$.storageID', '$.needsStorageServiceSync', '$.unknownFields', '$.storageProfileKey');\n    `\n  ).run();\n}\n\nfunction getAllConversationsSync(db = getInstance()): Array<ConversationType> {\n  const rows: ConversationRows = db\n    .prepare<EmptyQuery>(\n      `\n      SELECT json, profileLastFetchedAt\n      FROM conversations\n      ORDER BY id ASC;\n      `\n    )\n    .all();\n\n  return rows.map(row => rowToConversation(row));\n}\n\nasync function getAllConversations(): Promise<Array<ConversationType>> {\n  return getAllConversationsSync();\n}\n\nasync function getAllConversationIds(): Promise<Array<string>> {\n  const db = getInstance();\n  const rows: Array<{ id: string }> = db\n    .prepare<EmptyQuery>(\n      `\n      SELECT id FROM conversations ORDER BY id ASC;\n      `\n    )\n    .all();\n\n  return rows.map(row => row.id);\n}\n\nasync function getAllGroupsInvolvingUuid(\n  uuid: UUIDStringType\n): Promise<Array<ConversationType>> {\n  const db = getInstance();\n  const rows: ConversationRows = db\n    .prepare<Query>(\n      `\n      SELECT json, profileLastFetchedAt\n      FROM conversations WHERE\n        type = 'group' AND\n        members LIKE $uuid\n      ORDER BY id ASC;\n      `\n    )\n    .all({\n      uuid: `%${uuid}%`,\n    });\n\n  return rows.map(row => rowToConversation(row));\n}\n\nasync function searchMessages(\n  query: string,\n  params: { limit?: number; conversationId?: string } = {}\n): Promise<Array<ServerSearchResultMessageType>> {\n  const { limit = 500, conversationId } = params;\n\n  const db = getInstance();\n\n  // sqlite queries with a join on a virtual table (like FTS5) are de-optimized\n  // and can't use indices for ordering results. Instead an in-memory index of\n  // the join rows is sorted on the fly, and this becomes substantially\n  // slower when there are large columns in it (like `messages.json`).\n  //\n  // Thus here we take an indirect approach and store `rowid`s in a temporary\n  // table for all messages that match the FTS query. Then we create another\n  // table to sort and limit the results, and finally join on it when fetch\n  // the snippets and json. The benefit of this is that the `ORDER BY` and\n  // `LIMIT` happen without virtual table and are thus covered by\n  // `messages_searchOrder` index.\n  return db.transaction(() => {\n    db.exec(\n      `\n      CREATE TEMP TABLE tmp_results(rowid INTEGER PRIMARY KEY ASC);\n      CREATE TEMP TABLE tmp_filtered_results(rowid INTEGER PRIMARY KEY ASC);\n      `\n    );\n\n    db.prepare<Query>(\n      `\n        INSERT INTO tmp_results (rowid)\n        SELECT\n          rowid\n        FROM\n          messages_fts\n        WHERE\n          messages_fts.body MATCH $query;\n      `\n    ).run({ query });\n\n    if (conversationId === undefined) {\n      db.prepare<Query>(\n        `\n          INSERT INTO tmp_filtered_results (rowid)\n          SELECT\n            tmp_results.rowid\n          FROM\n            tmp_results\n          INNER JOIN\n            messages ON messages.rowid = tmp_results.rowid\n          ORDER BY messages.received_at DESC, messages.sent_at DESC\n          LIMIT $limit;\n        `\n      ).run({ limit });\n    } else {\n      db.prepare<Query>(\n        `\n          INSERT INTO tmp_filtered_results (rowid)\n          SELECT\n            tmp_results.rowid\n          FROM\n            tmp_results\n          INNER JOIN\n            messages ON messages.rowid = tmp_results.rowid\n          WHERE\n            messages.conversationId = $conversationId\n          ORDER BY messages.received_at DESC, messages.sent_at DESC\n          LIMIT $limit;\n        `\n      ).run({ conversationId, limit });\n    }\n\n    // The `MATCH` is necessary in order to for `snippet()` helper function to\n    // give us the right results. We can't call `snippet()` in the query above\n    // because it would bloat the temporary table with text data and we want\n    // to keep its size minimal for `ORDER BY` + `LIMIT` to be fast.\n    const result = db\n      .prepare<Query>(\n        `\n        SELECT\n          messages.json,\n          snippet(messages_fts, -1, '<<left>>', '<<right>>', '<<truncation>>', 10)\n            AS snippet\n        FROM tmp_filtered_results\n        INNER JOIN messages_fts\n          ON messages_fts.rowid = tmp_filtered_results.rowid\n        INNER JOIN messages\n          ON messages.rowid = tmp_filtered_results.rowid\n        WHERE\n          messages_fts.body MATCH $query\n        ORDER BY messages.received_at DESC, messages.sent_at DESC;\n        `\n      )\n      .all({ query });\n\n    db.exec(\n      `\n      DROP TABLE tmp_results;\n      DROP TABLE tmp_filtered_results;\n      `\n    );\n\n    return result;\n  })();\n}\n\nasync function searchMessagesInConversation(\n  query: string,\n  conversationId: string,\n  { limit = 100 }: { limit?: number } = {}\n): Promise<Array<ServerSearchResultMessageType>> {\n  return searchMessages(query, { conversationId, limit });\n}\n\nfunction getMessageCountSync(\n  conversationId?: string,\n  db = getInstance()\n): number {\n  if (conversationId === undefined) {\n    return getCountFromTable(db, 'messages');\n  }\n\n  const count = db\n    .prepare<Query>(\n      `\n        SELECT count(1)\n        FROM messages\n        WHERE conversationId = $conversationId;\n        `\n    )\n    .pluck()\n    .get({ conversationId });\n\n  return count;\n}\n\nasync function getStoryCount(conversationId: string): Promise<number> {\n  const db = getInstance();\n  return db\n    .prepare<Query>(\n      `\n        SELECT count(1)\n        FROM messages\n        WHERE conversationId = $conversationId AND isStory = 1;\n        `\n    )\n    .pluck()\n    .get({ conversationId });\n}\n\nasync function getMessageCount(conversationId?: string): Promise<number> {\n  return getMessageCountSync(conversationId);\n}\n\n// Note: we really only use this in 1:1 conversations, where story replies are always\n//   shown, so this has no need to be story-aware.\nfunction hasUserInitiatedMessages(conversationId: string): boolean {\n  const db = getInstance();\n\n  const exists: number = db\n    .prepare<Query>(\n      `\n      SELECT EXISTS(\n        SELECT 1 FROM messages\n        INDEXED BY message_user_initiated\n        WHERE\n          conversationId IS $conversationId AND\n          isUserInitiatedMessage IS 1\n      );\n      `\n    )\n    .pluck()\n    .get({ conversationId });\n\n  return exists !== 0;\n}\n\nfunction saveMessageSync(\n  data: MessageType,\n  options: {\n    alreadyInTransaction?: boolean;\n    db?: Database;\n    forceSave?: boolean;\n    jobToInsert?: StoredJob;\n    ourUuid: UUIDStringType;\n  }\n): string {\n  const {\n    alreadyInTransaction,\n    db = getInstance(),\n    forceSave,\n    jobToInsert,\n    ourUuid,\n  } = options;\n\n  if (!alreadyInTransaction) {\n    return db.transaction(() => {\n      return assertSync(\n        saveMessageSync(data, {\n          ...options,\n          alreadyInTransaction: true,\n        })\n      );\n    })();\n  }\n\n  const {\n    body,\n    conversationId,\n    groupV2Change,\n    hasAttachments,\n    hasFileAttachments,\n    hasVisualMediaAttachments,\n    id,\n    isErased,\n    isViewOnce,\n    received_at,\n    schemaVersion,\n    sent_at,\n    serverGuid,\n    source,\n    sourceUuid,\n    sourceDevice,\n    storyId,\n    type,\n    readStatus,\n    expireTimer,\n    expirationStartTimestamp,\n    attachments,\n  } = data;\n  let { seenStatus } = data;\n\n  if (attachments) {\n    strictAssert(\n      attachments.every(attachment => !attachment.data),\n      'Attempting to save a hydrated message'\n    );\n  }\n\n  if (readStatus === ReadStatus.Unread && seenStatus !== SeenStatus.Unseen) {\n    log.warn(\n      `saveMessage: Message ${id}/${type} is unread but had seenStatus=${seenStatus}. Forcing to UnseenStatus.Unseen.`\n    );\n\n    // eslint-disable-next-line no-param-reassign\n    data = {\n      ...data,\n      seenStatus: SeenStatus.Unseen,\n    };\n    seenStatus = SeenStatus.Unseen;\n  }\n\n  const payload = {\n    id,\n    json: objectToJSON(data),\n\n    body: body || null,\n    conversationId,\n    expirationStartTimestamp: expirationStartTimestamp || null,\n    expireTimer: expireTimer || null,\n    hasAttachments: hasAttachments ? 1 : 0,\n    hasFileAttachments: hasFileAttachments ? 1 : 0,\n    hasVisualMediaAttachments: hasVisualMediaAttachments ? 1 : 0,\n    isChangeCreatedByUs: groupV2Change?.from === ourUuid ? 1 : 0,\n    isErased: isErased ? 1 : 0,\n    isViewOnce: isViewOnce ? 1 : 0,\n    received_at: received_at || null,\n    schemaVersion: schemaVersion || 0,\n    serverGuid: serverGuid || null,\n    sent_at: sent_at || null,\n    source: source || null,\n    sourceUuid: sourceUuid || null,\n    sourceDevice: sourceDevice || null,\n    storyId: storyId || null,\n    type: type || null,\n    readStatus: readStatus ?? null,\n    seenStatus: seenStatus ?? SeenStatus.NotApplicable,\n  };\n\n  if (id && !forceSave) {\n    prepare(\n      db,\n      `\n      UPDATE messages SET\n        id = $id,\n        json = $json,\n\n        body = $body,\n        conversationId = $conversationId,\n        expirationStartTimestamp = $expirationStartTimestamp,\n        expireTimer = $expireTimer,\n        hasAttachments = $hasAttachments,\n        hasFileAttachments = $hasFileAttachments,\n        hasVisualMediaAttachments = $hasVisualMediaAttachments,\n        isChangeCreatedByUs = $isChangeCreatedByUs,\n        isErased = $isErased,\n        isViewOnce = $isViewOnce,\n        received_at = $received_at,\n        schemaVersion = $schemaVersion,\n        serverGuid = $serverGuid,\n        sent_at = $sent_at,\n        source = $source,\n        sourceUuid = $sourceUuid,\n        sourceDevice = $sourceDevice,\n        storyId = $storyId,\n        type = $type,\n        readStatus = $readStatus,\n        seenStatus = $seenStatus\n      WHERE id = $id;\n      `\n    ).run(payload);\n\n    if (jobToInsert) {\n      insertJobSync(db, jobToInsert);\n    }\n\n    return id;\n  }\n\n  const toCreate = {\n    ...data,\n    id: id || UUID.generate().toString(),\n  };\n\n  prepare(\n    db,\n    `\n    INSERT INTO messages (\n      id,\n      json,\n\n      body,\n      conversationId,\n      expirationStartTimestamp,\n      expireTimer,\n      hasAttachments,\n      hasFileAttachments,\n      hasVisualMediaAttachments,\n      isChangeCreatedByUs,\n      isErased,\n      isViewOnce,\n      received_at,\n      schemaVersion,\n      serverGuid,\n      sent_at,\n      source,\n      sourceUuid,\n      sourceDevice,\n      storyId,\n      type,\n      readStatus,\n      seenStatus\n    ) values (\n      $id,\n      $json,\n\n      $body,\n      $conversationId,\n      $expirationStartTimestamp,\n      $expireTimer,\n      $hasAttachments,\n      $hasFileAttachments,\n      $hasVisualMediaAttachments,\n      $isChangeCreatedByUs,\n      $isErased,\n      $isViewOnce,\n      $received_at,\n      $schemaVersion,\n      $serverGuid,\n      $sent_at,\n      $source,\n      $sourceUuid,\n      $sourceDevice,\n      $storyId,\n      $type,\n      $readStatus,\n      $seenStatus\n    );\n    `\n  ).run({\n    ...payload,\n    id: toCreate.id,\n    json: objectToJSON(toCreate),\n  });\n\n  if (jobToInsert) {\n    insertJobSync(db, jobToInsert);\n  }\n\n  return toCreate.id;\n}\n\nasync function saveMessage(\n  data: MessageType,\n  options: {\n    jobToInsert?: StoredJob;\n    forceSave?: boolean;\n    alreadyInTransaction?: boolean;\n    ourUuid: UUIDStringType;\n  }\n): Promise<string> {\n  return saveMessageSync(data, options);\n}\n\nasync function saveMessages(\n  arrayOfMessages: ReadonlyArray<MessageType>,\n  options: { forceSave?: boolean; ourUuid: UUIDStringType }\n): Promise<void> {\n  const db = getInstance();\n\n  db.transaction(() => {\n    for (const message of arrayOfMessages) {\n      assertSync(\n        saveMessageSync(message, { ...options, alreadyInTransaction: true })\n      );\n    }\n  })();\n}\n\nasync function removeMessage(id: string): Promise<void> {\n  const db = getInstance();\n\n  db.prepare<Query>('DELETE FROM messages WHERE id = $id;').run({ id });\n}\n\nfunction removeMessagesSync(ids: ReadonlyArray<string>): void {\n  const db = getInstance();\n\n  db.prepare<ArrayQuery>(\n    `\n    DELETE FROM messages\n    WHERE id IN ( ${ids.map(() => '?').join(', ')} );\n    `\n  ).run(ids);\n}\n\nasync function removeMessages(ids: ReadonlyArray<string>): Promise<void> {\n  batchMultiVarQuery(getInstance(), ids, removeMessagesSync);\n}\n\nasync function getMessageById(id: string): Promise<MessageType | undefined> {\n  const db = getInstance();\n  return getMessageByIdSync(db, id);\n}\n\nexport function getMessageByIdSync(\n  db: Database,\n  id: string\n): MessageType | undefined {\n  const row = db\n    .prepare<Query>('SELECT json FROM messages WHERE id = $id;')\n    .get({\n      id,\n    });\n\n  if (!row) {\n    return undefined;\n  }\n\n  return jsonToObject(row.json);\n}\n\nasync function getMessagesById(\n  messageIds: ReadonlyArray<string>\n): Promise<Array<MessageType>> {\n  const db = getInstance();\n\n  return batchMultiVarQuery(\n    db,\n    messageIds,\n    (batch: ReadonlyArray<string>): Array<MessageType> => {\n      const query = db.prepare<ArrayQuery>(\n        `SELECT json FROM messages WHERE id IN (${Array(batch.length)\n          .fill('?')\n          .join(',')});`\n      );\n      const rows: JSONRows = query.all(batch);\n      return rows.map(row => jsonToObject(row.json));\n    }\n  );\n}\n\nasync function _getAllMessages(): Promise<Array<MessageType>> {\n  const db = getInstance();\n  const rows: JSONRows = db\n    .prepare<EmptyQuery>('SELECT json FROM messages ORDER BY id ASC;')\n    .all();\n\n  return rows.map(row => jsonToObject(row.json));\n}\nasync function _removeAllMessages(): Promise<void> {\n  const db = getInstance();\n  db.exec(`\n    DELETE FROM messages;\n    INSERT INTO messages_fts(messages_fts) VALUES('optimize');\n  `);\n}\n\nasync function getAllMessageIds(): Promise<Array<string>> {\n  const db = getInstance();\n  const rows: Array<{ id: string }> = db\n    .prepare<EmptyQuery>('SELECT id FROM messages ORDER BY id ASC;')\n    .all();\n\n  return rows.map(row => row.id);\n}\n\nasync function getMessageBySender({\n  source,\n  sourceUuid,\n  sourceDevice,\n  sent_at,\n}: {\n  source?: string;\n  sourceUuid?: UUIDStringType;\n  sourceDevice?: number;\n  sent_at: number;\n}): Promise<MessageType | undefined> {\n  const db = getInstance();\n  const rows: JSONRows = prepare(\n    db,\n    `\n    SELECT json FROM messages WHERE\n      (source = $source OR sourceUuid = $sourceUuid) AND\n      sourceDevice = $sourceDevice AND\n      sent_at = $sent_at\n    LIMIT 2;\n    `\n  ).all({\n    source: source || null,\n    sourceUuid: sourceUuid || null,\n    sourceDevice: sourceDevice || null,\n    sent_at,\n  });\n\n  if (rows.length > 1) {\n    log.warn('getMessageBySender: More than one message found for', {\n      sent_at,\n      source,\n      sourceUuid,\n      sourceDevice,\n    });\n  }\n\n  if (rows.length < 1) {\n    return undefined;\n  }\n\n  return jsonToObject(rows[0].json);\n}\n\nexport function _storyIdPredicate(\n  storyId: string | undefined,\n  includeStoryReplies: boolean\n): QueryFragment {\n  // This is unintuitive, but 'including story replies' means that we need replies to\n  //   lots of different stories. So, we remove the storyId check with a clause that will\n  //   always be true. We don't just return TRUE because we want to use our passed-in\n  //   $storyId parameter.\n  if (includeStoryReplies && storyId === undefined) {\n    return sqlFragment`${storyId} IS NULL`;\n  }\n\n  // In contrast to: replies to a specific story\n  return sqlFragment`storyId IS ${storyId}`;\n}\n\nasync function getUnreadByConversationAndMarkRead({\n  conversationId,\n  includeStoryReplies,\n  newestUnreadAt,\n  storyId,\n  readAt,\n  now = Date.now(),\n}: {\n  conversationId: string;\n  includeStoryReplies: boolean;\n  newestUnreadAt: number;\n  storyId?: string;\n  readAt?: number;\n  now?: number;\n}): Promise<GetUnreadByConversationAndMarkReadResultType> {\n  const db = getInstance();\n  return db.transaction(() => {\n    const expirationStartTimestamp = Math.min(now, readAt ?? Infinity);\n\n    const expirationJsonPatch = JSON.stringify({ expirationStartTimestamp });\n\n    const [updateExpirationQuery, updateExpirationParams] = sql`\n      UPDATE messages\n      INDEXED BY expiring_message_by_conversation_and_received_at\n      SET\n        expirationStartTimestamp = ${expirationStartTimestamp},\n        json = json_patch(json, ${expirationJsonPatch})\n      WHERE\n        conversationId = ${conversationId} AND\n        (${_storyIdPredicate(storyId, includeStoryReplies)}) AND\n        isStory IS 0 AND\n        type IS 'incoming' AND\n        (\n          expirationStartTimestamp IS NULL OR\n          expirationStartTimestamp > ${expirationStartTimestamp}\n        ) AND\n        expireTimer > 0 AND\n        received_at <= ${newestUnreadAt};\n    `;\n\n    db.prepare(updateExpirationQuery).run(updateExpirationParams);\n\n    const [selectQuery, selectParams] = sql`\n      SELECT id, json FROM messages\n        WHERE\n          conversationId = ${conversationId} AND\n          seenStatus = ${SeenStatus.Unseen} AND\n          isStory = 0 AND\n          (${_storyIdPredicate(storyId, includeStoryReplies)}) AND\n          received_at <= ${newestUnreadAt}\n        ORDER BY received_at DESC, sent_at DESC;\n    `;\n\n    const rows = db.prepare(selectQuery).all(selectParams);\n\n    const statusJsonPatch = JSON.stringify({\n      readStatus: ReadStatus.Read,\n      seenStatus: SeenStatus.Seen,\n    });\n\n    const [updateStatusQuery, updateStatusParams] = sql`\n      UPDATE messages\n        SET\n          readStatus = ${ReadStatus.Read},\n          seenStatus = ${SeenStatus.Seen},\n          json = json_patch(json, ${statusJsonPatch})\n        WHERE\n          conversationId = ${conversationId} AND\n          seenStatus = ${SeenStatus.Unseen} AND\n          isStory = 0 AND\n          (${_storyIdPredicate(storyId, includeStoryReplies)}) AND\n          received_at <= ${newestUnreadAt};\n    `;\n\n    db.prepare(updateStatusQuery).run(updateStatusParams);\n\n    return rows.map(row => {\n      const json = jsonToObject<MessageType>(row.json);\n      return {\n        originalReadStatus: json.readStatus,\n        readStatus: ReadStatus.Read,\n        seenStatus: SeenStatus.Seen,\n        ...pick(json, [\n          'expirationStartTimestamp',\n          'id',\n          'sent_at',\n          'source',\n          'sourceUuid',\n          'type',\n        ]),\n      };\n    });\n  })();\n}\n\nasync function getUnreadReactionsAndMarkRead({\n  conversationId,\n  newestUnreadAt,\n  storyId,\n}: {\n  conversationId: string;\n  newestUnreadAt: number;\n  storyId?: string;\n}): Promise<Array<ReactionResultType>> {\n  const db = getInstance();\n\n  return db.transaction(() => {\n    const unreadMessages: Array<ReactionResultType> = db\n      .prepare<Query>(\n        `\n        SELECT reactions.rowid, targetAuthorUuid, targetTimestamp, messageId\n        FROM reactions\n        INDEXED BY reactions_unread\n        JOIN messages on messages.id IS reactions.messageId\n        WHERE\n          reactions.conversationId IS $conversationId AND\n          reactions.unread > 0 AND\n          messages.received_at <= $newestUnreadAt AND\n          messages.storyId IS $storyId\n        ORDER BY messageReceivedAt DESC;\n      `\n      )\n      .all({\n        conversationId,\n        newestUnreadAt,\n        storyId: storyId || null,\n      });\n\n    const idsToUpdate = unreadMessages.map(item => item.rowid);\n    batchMultiVarQuery(db, idsToUpdate, (ids: ReadonlyArray<number>): void => {\n      db.prepare<ArrayQuery>(\n        `\n        UPDATE reactions\n        SET unread = 0\n        WHERE rowid IN ( ${ids.map(() => '?').join(', ')} );\n        `\n      ).run(ids);\n    });\n\n    return unreadMessages;\n  })();\n}\n\nasync function markReactionAsRead(\n  targetAuthorUuid: string,\n  targetTimestamp: number\n): Promise<ReactionType | undefined> {\n  const db = getInstance();\n  return db.transaction(() => {\n    const readReaction = db\n      .prepare(\n        `\n          SELECT *\n          FROM reactions\n          WHERE\n            targetAuthorUuid = $targetAuthorUuid AND\n            targetTimestamp = $targetTimestamp AND\n            unread = 1\n          ORDER BY rowId DESC\n          LIMIT 1;\n        `\n      )\n      .get({\n        targetAuthorUuid,\n        targetTimestamp,\n      });\n\n    db.prepare(\n      `\n        UPDATE reactions SET\n        unread = 0 WHERE\n        targetAuthorUuid = $targetAuthorUuid AND\n        targetTimestamp = $targetTimestamp;\n      `\n    ).run({\n      targetAuthorUuid,\n      targetTimestamp,\n    });\n\n    return readReaction;\n  })();\n}\n\nasync function addReaction({\n  conversationId,\n  emoji,\n  fromId,\n  messageId,\n  messageReceivedAt,\n  targetAuthorUuid,\n  targetTimestamp,\n}: ReactionType): Promise<void> {\n  const db = getInstance();\n  await db\n    .prepare(\n      `INSERT INTO reactions (\n      conversationId,\n      emoji,\n      fromId,\n      messageId,\n      messageReceivedAt,\n      targetAuthorUuid,\n      targetTimestamp,\n      unread\n    ) VALUES (\n      $conversationId,\n      $emoji,\n      $fromId,\n      $messageId,\n      $messageReceivedAt,\n      $targetAuthorUuid,\n      $targetTimestamp,\n      $unread\n    );`\n    )\n    .run({\n      conversationId,\n      emoji,\n      fromId,\n      messageId,\n      messageReceivedAt,\n      targetAuthorUuid,\n      targetTimestamp,\n      unread: 1,\n    });\n}\n\nasync function removeReactionFromConversation({\n  emoji,\n  fromId,\n  targetAuthorUuid,\n  targetTimestamp,\n}: {\n  emoji: string;\n  fromId: string;\n  targetAuthorUuid: string;\n  targetTimestamp: number;\n}): Promise<void> {\n  const db = getInstance();\n  await db\n    .prepare(\n      `DELETE FROM reactions WHERE\n      emoji = $emoji AND\n      fromId = $fromId AND\n      targetAuthorUuid = $targetAuthorUuid AND\n      targetTimestamp = $targetTimestamp;`\n    )\n    .run({\n      emoji,\n      fromId,\n      targetAuthorUuid,\n      targetTimestamp,\n    });\n}\n\nasync function _getAllReactions(): Promise<Array<ReactionType>> {\n  const db = getInstance();\n  return db.prepare<EmptyQuery>('SELECT * from reactions;').all();\n}\nasync function _removeAllReactions(): Promise<void> {\n  const db = getInstance();\n  db.prepare<EmptyQuery>('DELETE from reactions;').run();\n}\n\nenum AdjacentDirection {\n  Older = 'Older',\n  Newer = 'Newer',\n}\n\nfunction getAdjacentMessagesByConversationSync(\n  direction: AdjacentDirection,\n  {\n    conversationId,\n    includeStoryReplies,\n    limit = 100,\n    messageId,\n    receivedAt = direction === AdjacentDirection.Older ? Number.MAX_VALUE : 0,\n    sentAt = direction === AdjacentDirection.Older ? Number.MAX_VALUE : 0,\n    requireVisualMediaAttachments,\n    storyId,\n  }: AdjacentMessagesByConversationOptionsType\n): Array<MessageTypeUnhydrated> {\n  const db = getInstance();\n\n  const timeFilter =\n    direction === AdjacentDirection.Older\n      ? sqlFragment`\n        (received_at = ${receivedAt} AND sent_at < ${sentAt}) OR\n        received_at < ${receivedAt}\n      `\n      : sqlFragment`\n        (received_at = ${receivedAt} AND sent_at > ${sentAt}) OR\n        received_at > ${receivedAt}\n      `;\n\n  const timeOrder =\n    direction === AdjacentDirection.Older\n      ? sqlFragment`DESC`\n      : sqlFragment`ASC`;\n\n  const requireDifferentMessage =\n    direction === AdjacentDirection.Older || requireVisualMediaAttachments;\n\n  let template = sqlFragment`\n    SELECT json FROM messages WHERE\n      conversationId = ${conversationId} AND\n      ${\n        requireDifferentMessage\n          ? sqlFragment`(${messageId} IS NULL OR id IS NOT ${messageId}) AND`\n          : sqlFragment``\n      }\n      ${\n        requireVisualMediaAttachments\n          ? sqlFragment`hasVisualMediaAttachments IS 1 AND`\n          : sqlFragment``\n      }\n      isStory IS 0 AND\n      (${_storyIdPredicate(storyId, includeStoryReplies)}) AND\n      (\n        ${timeFilter}\n      )\n    ORDER BY received_at ${timeOrder}, sent_at ${timeOrder}\n  `;\n\n  // See `filterValidAttachments` in ts/state/ducks/lightbox.ts\n  if (requireVisualMediaAttachments) {\n    template = sqlFragment`\n      SELECT json\n      FROM (${template}) as messages\n      WHERE\n        (\n          SELECT COUNT(*)\n          FROM json_each(messages.json ->> 'attachments') AS attachment\n          WHERE\n            attachment.value ->> 'thumbnail' IS NOT NULL AND\n            attachment.value ->> 'pending' IS NOT 1 AND\n            attachment.value ->> 'error' IS NULL\n        ) > 0\n      LIMIT ${limit};\n    `;\n  } else {\n    template = sqlFragment`${template} LIMIT ${limit}`;\n  }\n\n  const [query, params] = sql`${template}`;\n\n  const results = db.prepare(query).all(params);\n\n  if (direction === AdjacentDirection.Older) {\n    results.reverse();\n  }\n\n  return results;\n}\n\nasync function getOlderMessagesByConversation(\n  options: AdjacentMessagesByConversationOptionsType\n): Promise<Array<MessageTypeUnhydrated>> {\n  return getAdjacentMessagesByConversationSync(\n    AdjacentDirection.Older,\n    options\n  );\n}\n\nasync function getAllStories({\n  conversationId,\n  sourceUuid,\n}: {\n  conversationId?: string;\n  sourceUuid?: UUIDStringType;\n}): Promise<GetAllStoriesResultType> {\n  const db = getInstance();\n  const rows: ReadonlyArray<{\n    json: string;\n    hasReplies: number;\n    hasRepliesFromSelf: number;\n  }> = db\n    .prepare<Query>(\n      `\n      SELECT\n        json,\n        (SELECT EXISTS(\n          SELECT 1\n          FROM messages as replies\n          WHERE replies.storyId IS messages.id\n        )) as hasReplies,\n        (SELECT EXISTS(\n          SELECT 1\n          FROM messages AS selfReplies\n          WHERE\n            selfReplies.storyId IS messages.id AND\n            selfReplies.type IS 'outgoing'\n        )) as hasRepliesFromSelf\n      FROM messages\n      WHERE\n        type IS 'story' AND\n        ($conversationId IS NULL OR conversationId IS $conversationId) AND\n        ($sourceUuid IS NULL OR sourceUuid IS $sourceUuid)\n      ORDER BY received_at ASC, sent_at ASC;\n      `\n    )\n    .all({\n      conversationId: conversationId || null,\n      sourceUuid: sourceUuid || null,\n    });\n\n  return rows.map(row => ({\n    ...jsonToObject(row.json),\n    hasReplies: row.hasReplies !== 0,\n    hasRepliesFromSelf: row.hasRepliesFromSelf !== 0,\n  }));\n}\n\nasync function getNewerMessagesByConversation(\n  options: AdjacentMessagesByConversationOptionsType\n): Promise<Array<MessageTypeUnhydrated>> {\n  return getAdjacentMessagesByConversationSync(\n    AdjacentDirection.Newer,\n    options\n  );\n}\nfunction getOldestMessageForConversation(\n  conversationId: string,\n  {\n    storyId,\n    includeStoryReplies,\n  }: {\n    storyId?: string;\n    includeStoryReplies: boolean;\n  }\n): MessageMetricsType | undefined {\n  const db = getInstance();\n  const [query, params] = sql`\n    SELECT received_at, sent_at, id FROM messages WHERE\n        conversationId = ${conversationId} AND\n        isStory IS 0 AND\n        (${_storyIdPredicate(storyId, includeStoryReplies)})\n      ORDER BY received_at ASC, sent_at ASC\n      LIMIT 1;\n  `;\n\n  const row = db.prepare(query).get(params);\n\n  if (!row) {\n    return undefined;\n  }\n\n  return row;\n}\nfunction getNewestMessageForConversation(\n  conversationId: string,\n  {\n    storyId,\n    includeStoryReplies,\n  }: {\n    storyId?: string;\n    includeStoryReplies: boolean;\n  }\n): MessageMetricsType | undefined {\n  const db = getInstance();\n  const [query, params] = sql`\n    SELECT received_at, sent_at, id FROM messages WHERE\n        conversationId = ${conversationId} AND\n        isStory IS 0 AND\n        (${_storyIdPredicate(storyId, includeStoryReplies)})\n      ORDER BY received_at DESC, sent_at DESC\n      LIMIT 1;\n  `;\n  const row = db.prepare(query).get(params);\n\n  if (!row) {\n    return undefined;\n  }\n\n  return row;\n}\n\nexport type GetMessagesBetweenOptions = Readonly<{\n  after: { received_at: number; sent_at: number };\n  before: { received_at: number; sent_at: number };\n  includeStoryReplies: boolean;\n}>;\n\nasync function getMessagesBetween(\n  conversationId: string,\n  options: GetMessagesBetweenOptions\n): Promise<Array<string>> {\n  const db = getInstance();\n\n  // In the future we could accept this as an option, but for now we just\n  // use it for the story predicate.\n  const storyId = undefined;\n\n  const { after, before, includeStoryReplies } = options;\n\n  const [query, params] = sql`\n    SELECT id\n    FROM messages\n    WHERE\n      conversationId = ${conversationId} AND\n      (${_storyIdPredicate(storyId, includeStoryReplies)}) AND\n      isStory IS 0 AND\n      (\n        received_at > ${after.received_at}\n        OR (received_at = ${after.received_at} AND sent_at > ${after.sent_at})\n      ) AND (\n        received_at < ${before.received_at}\n        OR (received_at = ${before.received_at} AND sent_at < ${before.sent_at})\n      )\n    ORDER BY received_at ASC, sent_at ASC;\n  `;\n\n  const rows = db.prepare(query).all(params);\n\n  return rows.map(row => row.id);\n}\n\n/**\n * Given a set of deleted message IDs, find a message in the conversation that\n * is close to the set. Searching from the last selected message as a starting\n * point.\n */\nasync function getNearbyMessageFromDeletedSet({\n  conversationId,\n  lastSelectedMessage,\n  deletedMessageIds,\n  storyId,\n  includeStoryReplies,\n}: GetNearbyMessageFromDeletedSetOptionsType): Promise<string | null> {\n  const db = getInstance();\n\n  function runQuery(after: boolean) {\n    const dir = after ? sqlFragment`ASC` : sqlFragment`DESC`;\n    const compare = after ? sqlFragment`>` : sqlFragment`<`;\n    const { received_at, sent_at } = lastSelectedMessage;\n\n    const [query, params] = sql`\n      SELECT id FROM messages WHERE\n        conversationId = ${conversationId} AND\n        (${_storyIdPredicate(storyId, includeStoryReplies)}) AND\n        isStory IS 0 AND\n        id NOT IN (${sqlJoin(deletedMessageIds, ', ')}) AND\n        type IN ('incoming', 'outgoing')\n        AND (\n          (received_at = ${received_at} AND sent_at ${compare} ${sent_at}) OR\n          received_at ${compare} ${received_at}\n        )\n      ORDER BY received_at ${dir}, sent_at ${dir}\n      LIMIT 1\n    `;\n\n    return db.prepare(query).pluck().get(params);\n  }\n\n  const after = runQuery(true);\n  if (after != null) {\n    return after;\n  }\n\n  const before = runQuery(false);\n  if (before != null) {\n    return before;\n  }\n\n  return null;\n}\n\nfunction getLastConversationActivity({\n  conversationId,\n  includeStoryReplies,\n  ourUuid,\n}: {\n  conversationId: string;\n  includeStoryReplies: boolean;\n  ourUuid: UUIDStringType;\n}): MessageType | undefined {\n  const db = getInstance();\n  const row = prepare(\n    db,\n    `\n      SELECT json FROM messages\n      INDEXED BY messages_activity\n      WHERE\n        conversationId IS $conversationId AND\n        shouldAffectActivity IS 1 AND\n        isTimerChangeFromSync IS 0 AND\n        ${includeStoryReplies ? '' : 'storyId IS NULL AND'}\n        isGroupLeaveEventFromOther IS 0\n      ORDER BY received_at DESC, sent_at DESC\n      LIMIT 1;\n      `\n  ).get({\n    conversationId,\n    ourUuid,\n  });\n\n  if (!row) {\n    return undefined;\n  }\n\n  return jsonToObject(row.json);\n}\nfunction getLastConversationPreview({\n  conversationId,\n  includeStoryReplies,\n}: {\n  conversationId: string;\n  includeStoryReplies: boolean;\n}): MessageType | undefined {\n  type Row = Readonly<{\n    json: string;\n  }>;\n\n  const db = getInstance();\n\n  const index = includeStoryReplies\n    ? 'messages_preview'\n    : 'messages_preview_without_story';\n\n  const row: Row | undefined = prepare(\n    db,\n    `\n      SELECT json FROM (\n        SELECT json, expiresAt FROM messages\n        INDEXED BY ${index}\n        WHERE\n          conversationId IS $conversationId AND\n          shouldAffectPreview IS 1 AND\n          isGroupLeaveEventFromOther IS 0\n          ${includeStoryReplies ? '' : 'AND storyId IS NULL'}\n        ORDER BY received_at DESC, sent_at DESC\n      )\n      WHERE likely(expiresAt > $now)\n      LIMIT 1\n    `\n  ).get({\n    conversationId,\n    now: Date.now(),\n  });\n\n  return row ? jsonToObject(row.json) : undefined;\n}\n\nasync function getConversationMessageStats({\n  conversationId,\n  includeStoryReplies,\n  ourUuid,\n}: {\n  conversationId: string;\n  includeStoryReplies: boolean;\n  ourUuid: UUIDStringType;\n}): Promise<ConversationMessageStatsType> {\n  const db = getInstance();\n\n  return db.transaction(() => {\n    return {\n      activity: getLastConversationActivity({\n        conversationId,\n        includeStoryReplies,\n        ourUuid,\n      }),\n      preview: getLastConversationPreview({\n        conversationId,\n        includeStoryReplies,\n      }),\n      hasUserInitiatedMessages: hasUserInitiatedMessages(conversationId),\n    };\n  })();\n}\n\nasync function getLastConversationMessage({\n  conversationId,\n}: {\n  conversationId: string;\n}): Promise<MessageType | undefined> {\n  const db = getInstance();\n  const row = db\n    .prepare<Query>(\n      `\n      SELECT json FROM messages WHERE\n        conversationId = $conversationId\n      ORDER BY received_at DESC, sent_at DESC\n      LIMIT 1;\n      `\n    )\n    .get({\n      conversationId,\n    });\n\n  if (!row) {\n    return undefined;\n  }\n\n  return jsonToObject(row.json);\n}\n\nfunction getOldestUnseenMessageForConversation(\n  conversationId: string,\n  {\n    storyId,\n    includeStoryReplies,\n  }: {\n    storyId?: string;\n    includeStoryReplies: boolean;\n  }\n): MessageMetricsType | undefined {\n  const db = getInstance();\n\n  const [query, params] = sql`\n    SELECT received_at, sent_at, id FROM messages WHERE\n      conversationId = ${conversationId} AND\n      seenStatus = ${SeenStatus.Unseen} AND\n      isStory IS 0 AND\n      (${_storyIdPredicate(storyId, includeStoryReplies)})\n    ORDER BY received_at ASC, sent_at ASC\n    LIMIT 1;\n  `;\n\n  const row = db.prepare(query).get(params);\n\n  if (!row) {\n    return undefined;\n  }\n\n  return row;\n}\n\nasync function getTotalUnreadForConversation(\n  conversationId: string,\n  options: {\n    storyId: string | undefined;\n    includeStoryReplies: boolean;\n  }\n): Promise<number> {\n  return getTotalUnreadForConversationSync(conversationId, options);\n}\nfunction getTotalUnreadForConversationSync(\n  conversationId: string,\n  {\n    storyId,\n    includeStoryReplies,\n  }: {\n    storyId: string | undefined;\n    includeStoryReplies: boolean;\n  }\n): number {\n  const db = getInstance();\n  const [query, params] = sql`\n    SELECT count(1)\n    FROM messages\n    WHERE\n      conversationId = ${conversationId} AND\n      readStatus = ${ReadStatus.Unread} AND\n      isStory IS 0 AND\n      (${_storyIdPredicate(storyId, includeStoryReplies)})\n  `;\n  const row = db.prepare(query).pluck().get(params);\n\n  return row;\n}\nfunction getTotalUnseenForConversationSync(\n  conversationId: string,\n  {\n    storyId,\n    includeStoryReplies,\n  }: {\n    storyId?: string;\n    includeStoryReplies: boolean;\n  }\n): number {\n  const db = getInstance();\n  const [query, params] = sql`\n    SELECT count(1)\n      FROM messages\n      WHERE\n        conversationId = ${conversationId} AND\n        seenStatus = ${SeenStatus.Unseen} AND\n        isStory IS 0 AND\n        (${_storyIdPredicate(storyId, includeStoryReplies)})\n  `;\n  const row = db.prepare(query).pluck().get(params);\n\n  return row;\n}\n\nasync function getMessageMetricsForConversation(options: {\n  conversationId: string;\n  storyId?: string;\n  includeStoryReplies: boolean;\n}): Promise<ConversationMetricsType> {\n  return getMessageMetricsForConversationSync(options);\n}\nfunction getMessageMetricsForConversationSync(options: {\n  conversationId: string;\n  storyId?: string;\n  includeStoryReplies: boolean;\n}): ConversationMetricsType {\n  const { conversationId } = options;\n  const oldest = getOldestMessageForConversation(conversationId, options);\n  const newest = getNewestMessageForConversation(conversationId, options);\n  const oldestUnseen = getOldestUnseenMessageForConversation(\n    conversationId,\n    options\n  );\n  const totalUnseen = getTotalUnseenForConversationSync(\n    conversationId,\n    options\n  );\n\n  return {\n    oldest: oldest ? pick(oldest, ['received_at', 'sent_at', 'id']) : undefined,\n    newest: newest ? pick(newest, ['received_at', 'sent_at', 'id']) : undefined,\n    oldestUnseen: oldestUnseen\n      ? pick(oldestUnseen, ['received_at', 'sent_at', 'id'])\n      : undefined,\n    totalUnseen,\n  };\n}\n\nasync function getConversationRangeCenteredOnMessage(\n  options: AdjacentMessagesByConversationOptionsType\n): Promise<\n  GetConversationRangeCenteredOnMessageResultType<MessageTypeUnhydrated>\n> {\n  const db = getInstance();\n\n  return db.transaction(() => {\n    return {\n      older: getAdjacentMessagesByConversationSync(\n        AdjacentDirection.Older,\n        options\n      ),\n      newer: getAdjacentMessagesByConversationSync(\n        AdjacentDirection.Newer,\n        options\n      ),\n      metrics: getMessageMetricsForConversationSync(options),\n    };\n  })();\n}\n\nasync function getCallHistoryMessageByCallId(\n  conversationId: string,\n  callId: string\n): Promise<string | void> {\n  const db = getInstance();\n\n  const id: string | void = db\n    .prepare<Query>(\n      `\n      SELECT id\n      FROM messages\n      WHERE conversationId = $conversationId\n        AND type = 'call-history'\n        AND callMode = 'Direct'\n        AND callId = $callId\n    `\n    )\n    .pluck()\n    .get({\n      conversationId,\n      callId,\n    });\n\n  return id;\n}\n\nasync function hasGroupCallHistoryMessage(\n  conversationId: string,\n  eraId: string\n): Promise<boolean> {\n  const db = getInstance();\n\n  const exists: number = db\n    .prepare<Query>(\n      `\n      SELECT EXISTS(\n        SELECT 1 FROM messages\n        WHERE conversationId = $conversationId\n        AND type = 'call-history'\n        AND json_extract(json, '$.callHistoryDetails.callMode') = 'Group'\n        AND json_extract(json, '$.callHistoryDetails.eraId') = $eraId\n      );\n      `\n    )\n    .pluck()\n    .get({\n      conversationId,\n      eraId,\n    });\n\n  return exists !== 0;\n}\n\nasync function migrateConversationMessages(\n  obsoleteId: string,\n  currentId: string\n): Promise<void> {\n  const db = getInstance();\n\n  db.prepare<Query>(\n    `\n    UPDATE messages SET\n      conversationId = $currentId,\n      json = json_set(json, '$.conversationId', $currentId)\n    WHERE conversationId = $obsoleteId;\n    `\n  ).run({\n    obsoleteId,\n    currentId,\n  });\n}\n\nasync function getMessagesBySentAt(\n  sentAt: number\n): Promise<Array<MessageType>> {\n  const db = getInstance();\n\n  const [query, params] = sql`\n      SELECT messages.json, received_at, sent_at FROM edited_messages\n      INNER JOIN messages ON\n        messages.id = edited_messages.messageId\n      WHERE edited_messages.sentAt = ${sentAt}\n      UNION\n      SELECT json, received_at, sent_at FROM messages\n      WHERE sent_at = ${sentAt}\n      ORDER BY messages.received_at DESC, messages.sent_at DESC;\n    `;\n\n  const rows = db.prepare(query).all(params);\n\n  return rows.map(row => jsonToObject(row.json));\n}\n\nasync function getExpiredMessages(): Promise<Array<MessageType>> {\n  const db = getInstance();\n  const now = Date.now();\n\n  const rows: JSONRows = db\n    .prepare<Query>(\n      `\n      SELECT json FROM messages WHERE\n        expiresAt <= $now\n      ORDER BY expiresAt ASC;\n      `\n    )\n    .all({ now });\n\n  return rows.map(row => jsonToObject(row.json));\n}\n\nasync function getMessagesUnexpectedlyMissingExpirationStartTimestamp(): Promise<\n  Array<MessageType>\n> {\n  const db = getInstance();\n  const rows: JSONRows = db\n    .prepare<EmptyQuery>(\n      `\n      SELECT json FROM messages\n      INDEXED BY messages_unexpectedly_missing_expiration_start_timestamp\n      WHERE\n        expireTimer > 0 AND\n        expirationStartTimestamp IS NULL AND\n        (\n          type IS 'outgoing' OR\n          (type IS 'incoming' AND (\n            readStatus = ${ReadStatus.Read} OR\n            readStatus = ${ReadStatus.Viewed} OR\n            readStatus IS NULL\n          ))\n        );\n      `\n    )\n    .all();\n\n  return rows.map(row => jsonToObject(row.json));\n}\n\nasync function getSoonestMessageExpiry(): Promise<undefined | number> {\n  const db = getInstance();\n\n  // Note: we use `pluck` to only get the first column.\n  const result: null | number = db\n    .prepare<EmptyQuery>(\n      `\n      SELECT MIN(expiresAt)\n      FROM messages;\n      `\n    )\n    .pluck(true)\n    .get();\n\n  if (result != null && result >= Number.MAX_SAFE_INTEGER) {\n    return undefined;\n  }\n\n  return result || undefined;\n}\n\nasync function getNextTapToViewMessageTimestampToAgeOut(): Promise<\n  undefined | number\n> {\n  const db = getInstance();\n  const row = db\n    .prepare<EmptyQuery>(\n      `\n      SELECT json FROM messages\n      WHERE\n        isViewOnce = 1\n        AND (isErased IS NULL OR isErased != 1)\n      ORDER BY received_at ASC, sent_at ASC\n      LIMIT 1;\n      `\n    )\n    .get();\n\n  if (!row) {\n    return undefined;\n  }\n\n  const data = jsonToObject<MessageType>(row.json);\n  const result = data.received_at_ms || data.received_at;\n  return isNormalNumber(result) ? result : undefined;\n}\n\nasync function getTapToViewMessagesNeedingErase(): Promise<Array<MessageType>> {\n  const db = getInstance();\n  const THIRTY_DAYS_AGO = Date.now() - 30 * 24 * 60 * 60 * 1000;\n\n  const rows: JSONRows = db\n    .prepare<Query>(\n      `\n      SELECT json\n      FROM messages\n      WHERE\n        isViewOnce = 1\n        AND (isErased IS NULL OR isErased != 1)\n        AND received_at <= $THIRTY_DAYS_AGO\n      ORDER BY received_at ASC, sent_at ASC;\n      `\n    )\n    .all({\n      THIRTY_DAYS_AGO,\n    });\n\n  return rows.map(row => jsonToObject(row.json));\n}\n\nconst MAX_UNPROCESSED_ATTEMPTS = 3;\n\nfunction saveUnprocessedSync(data: UnprocessedType): string {\n  const db = getInstance();\n  const {\n    id,\n    timestamp,\n    receivedAtCounter,\n    version,\n    attempts,\n    envelope,\n    source,\n    sourceUuid,\n    sourceDevice,\n    serverGuid,\n    serverTimestamp,\n    decrypted,\n    urgent,\n    story,\n  } = data;\n  if (!id) {\n    throw new Error('saveUnprocessedSync: id was falsey');\n  }\n\n  prepare(\n    db,\n    `\n    INSERT OR REPLACE INTO unprocessed (\n      id,\n      timestamp,\n      receivedAtCounter,\n      version,\n      attempts,\n      envelope,\n      source,\n      sourceUuid,\n      sourceDevice,\n      serverGuid,\n      serverTimestamp,\n      decrypted,\n      urgent,\n      story\n    ) values (\n      $id,\n      $timestamp,\n      $receivedAtCounter,\n      $version,\n      $attempts,\n      $envelope,\n      $source,\n      $sourceUuid,\n      $sourceDevice,\n      $serverGuid,\n      $serverTimestamp,\n      $decrypted,\n      $urgent,\n      $story\n    );\n    `\n  ).run({\n    id,\n    timestamp,\n    receivedAtCounter: receivedAtCounter ?? null,\n    version,\n    attempts,\n    envelope: envelope || null,\n    source: source || null,\n    sourceUuid: sourceUuid || null,\n    sourceDevice: sourceDevice || null,\n    serverGuid: serverGuid || null,\n    serverTimestamp: serverTimestamp || null,\n    decrypted: decrypted || null,\n    urgent: urgent || !isBoolean(urgent) ? 1 : 0,\n    story: story ? 1 : 0,\n  });\n\n  return id;\n}\n\nfunction updateUnprocessedWithDataSync(\n  id: string,\n  data: UnprocessedUpdateType\n): void {\n  const db = getInstance();\n  const {\n    source,\n    sourceUuid,\n    sourceDevice,\n    serverGuid,\n    serverTimestamp,\n    decrypted,\n  } = data;\n\n  prepare(\n    db,\n    `\n    UPDATE unprocessed SET\n      source = $source,\n      sourceUuid = $sourceUuid,\n      sourceDevice = $sourceDevice,\n      serverGuid = $serverGuid,\n      serverTimestamp = $serverTimestamp,\n      decrypted = $decrypted\n    WHERE id = $id;\n    `\n  ).run({\n    id,\n    source: source || null,\n    sourceUuid: sourceUuid || null,\n    sourceDevice: sourceDevice || null,\n    serverGuid: serverGuid || null,\n    serverTimestamp: serverTimestamp || null,\n    decrypted: decrypted || null,\n  });\n}\n\nasync function updateUnprocessedWithData(\n  id: string,\n  data: UnprocessedUpdateType\n): Promise<void> {\n  return updateUnprocessedWithDataSync(id, data);\n}\n\nasync function updateUnprocessedsWithData(\n  arrayOfUnprocessed: Array<{ id: string; data: UnprocessedUpdateType }>\n): Promise<void> {\n  const db = getInstance();\n\n  db.transaction(() => {\n    for (const { id, data } of arrayOfUnprocessed) {\n      assertSync(updateUnprocessedWithDataSync(id, data));\n    }\n  })();\n}\n\nasync function getUnprocessedById(\n  id: string\n): Promise<UnprocessedType | undefined> {\n  const db = getInstance();\n  const row = db\n    .prepare<Query>('SELECT * FROM unprocessed WHERE id = $id;')\n    .get({\n      id,\n    });\n\n  return {\n    ...row,\n    urgent: isNumber(row.urgent) ? Boolean(row.urgent) : true,\n    story: Boolean(row.story),\n  };\n}\n\nasync function getUnprocessedCount(): Promise<number> {\n  return getCountFromTable(getInstance(), 'unprocessed');\n}\n\nasync function getAllUnprocessedIds(): Promise<Array<string>> {\n  log.info('getAllUnprocessedIds');\n  const db = getInstance();\n\n  return db.transaction(() => {\n    // cleanup first\n    const { changes: deletedStaleCount } = db\n      .prepare<Query>('DELETE FROM unprocessed WHERE timestamp < $monthAgo')\n      .run({\n        monthAgo: Date.now() - durations.MONTH,\n      });\n\n    if (deletedStaleCount !== 0) {\n      logger.warn(\n        'getAllUnprocessedAndIncrementAttempts: ' +\n          `deleting ${deletedStaleCount} old unprocessed envelopes`\n      );\n    }\n\n    const { changes: deletedInvalidCount } = db\n      .prepare<Query>(\n        `\n          DELETE FROM unprocessed\n          WHERE attempts >= $MAX_UNPROCESSED_ATTEMPTS\n        `\n      )\n      .run({ MAX_UNPROCESSED_ATTEMPTS });\n\n    if (deletedInvalidCount !== 0) {\n      logger.warn(\n        'getAllUnprocessedAndIncrementAttempts: ' +\n          `deleting ${deletedInvalidCount} invalid unprocessed envelopes`\n      );\n    }\n\n    return db\n      .prepare<EmptyQuery>(\n        `\n          SELECT id\n          FROM unprocessed\n          ORDER BY receivedAtCounter ASC\n        `\n      )\n      .pluck()\n      .all();\n  })();\n}\n\nasync function getUnprocessedByIdsAndIncrementAttempts(\n  ids: ReadonlyArray<string>\n): Promise<Array<UnprocessedType>> {\n  log.info('getUnprocessedByIdsAndIncrementAttempts', { totalIds: ids.length });\n\n  const db = getInstance();\n\n  batchMultiVarQuery(db, ids, batch => {\n    return db\n      .prepare<ArrayQuery>(\n        `\n          UPDATE unprocessed\n          SET attempts = attempts + 1\n          WHERE id IN (${batch.map(() => '?').join(', ')})\n        `\n      )\n      .run(batch);\n  });\n\n  return batchMultiVarQuery(db, ids, batch => {\n    return db\n      .prepare<ArrayQuery>(\n        `\n          SELECT *\n          FROM unprocessed\n          WHERE id IN (${batch.map(() => '?').join(', ')})\n          ORDER BY receivedAtCounter ASC;\n        `\n      )\n      .all(batch)\n      .map(row => ({\n        ...row,\n        urgent: isNumber(row.urgent) ? Boolean(row.urgent) : true,\n        story: Boolean(row.story),\n      }));\n  });\n}\n\nfunction removeUnprocessedsSync(ids: ReadonlyArray<string>): void {\n  log.info('removeUnprocessedsSync', { totalIds: ids.length });\n  const db = getInstance();\n\n  db.prepare<ArrayQuery>(\n    `\n    DELETE FROM unprocessed\n    WHERE id IN ( ${ids.map(() => '?').join(', ')} );\n    `\n  ).run(ids);\n}\n\nfunction removeUnprocessedSync(id: string | Array<string>): void {\n  log.info('removeUnprocessedSync', { id });\n  const db = getInstance();\n\n  if (!Array.isArray(id)) {\n    prepare(db, 'DELETE FROM unprocessed WHERE id = $id;').run({ id });\n\n    return;\n  }\n\n  // This can happen normally due to flushing of `cacheRemoveBatcher` in\n  // MessageReceiver.\n  if (!id.length) {\n    return;\n  }\n\n  assertSync(batchMultiVarQuery(db, id, removeUnprocessedsSync));\n}\n\nasync function removeUnprocessed(id: string | Array<string>): Promise<void> {\n  removeUnprocessedSync(id);\n}\n\nasync function removeAllUnprocessed(): Promise<void> {\n  const db = getInstance();\n  db.prepare<EmptyQuery>('DELETE FROM unprocessed;').run();\n}\n\n// Attachment Downloads\n\nconst ATTACHMENT_DOWNLOADS_TABLE = 'attachment_downloads';\nasync function getAttachmentDownloadJobById(\n  id: string\n): Promise<AttachmentDownloadJobType | undefined> {\n  return getById(getInstance(), ATTACHMENT_DOWNLOADS_TABLE, id);\n}\nasync function getNextAttachmentDownloadJobs(\n  limit?: number,\n  options: { timestamp?: number } = {}\n): Promise<Array<AttachmentDownloadJobType>> {\n  const db = getInstance();\n  const timestamp =\n    options && options.timestamp ? options.timestamp : Date.now();\n\n  const rows: Array<{ json: string; id: string }> = db\n    .prepare<Query>(\n      `\n      SELECT id, json\n      FROM attachment_downloads\n      WHERE pending = 0 AND timestamp <= $timestamp\n      ORDER BY timestamp DESC\n      LIMIT $limit;\n      `\n    )\n    .all({\n      limit: limit || 3,\n      timestamp,\n    });\n\n  const INNER_ERROR = 'jsonToObject error';\n  try {\n    return rows.map(row => {\n      try {\n        return jsonToObject(row.json);\n      } catch (error) {\n        logger.error(\n          `getNextAttachmentDownloadJobs: Error with job '${row.id}', deleting. ` +\n            `JSON: '${row.json}' ` +\n            `Error: ${Errors.toLogFormat(error)}`\n        );\n        removeAttachmentDownloadJobSync(row.id);\n        throw new Error(INNER_ERROR);\n      }\n    });\n  } catch (error) {\n    if ('message' in error && error.message === INNER_ERROR) {\n      return getNextAttachmentDownloadJobs(limit, { timestamp });\n    }\n    throw error;\n  }\n}\nasync function saveAttachmentDownloadJob(\n  job: AttachmentDownloadJobType\n): Promise<void> {\n  const db = getInstance();\n  const { id, pending, timestamp } = job;\n  if (!id) {\n    throw new Error(\n      'saveAttachmentDownloadJob: Provided job did not have a truthy id'\n    );\n  }\n\n  db.prepare<Query>(\n    `\n    INSERT OR REPLACE INTO attachment_downloads (\n      id,\n      pending,\n      timestamp,\n      json\n    ) values (\n      $id,\n      $pending,\n      $timestamp,\n      $json\n    )\n    `\n  ).run({\n    id,\n    pending,\n    timestamp,\n    json: objectToJSON(job),\n  });\n}\nasync function setAttachmentDownloadJobPending(\n  id: string,\n  pending: boolean\n): Promise<void> {\n  const db = getInstance();\n  db.prepare<Query>(\n    `\n    UPDATE attachment_downloads\n    SET pending = $pending\n    WHERE id = $id;\n    `\n  ).run({\n    id,\n    pending: pending ? 1 : 0,\n  });\n}\nasync function resetAttachmentDownloadPending(): Promise<void> {\n  const db = getInstance();\n  db.prepare<EmptyQuery>(\n    `\n    UPDATE attachment_downloads\n    SET pending = 0\n    WHERE pending != 0;\n    `\n  ).run();\n}\nfunction removeAttachmentDownloadJobSync(id: string): void {\n  return removeById(getInstance(), ATTACHMENT_DOWNLOADS_TABLE, id);\n}\nasync function removeAttachmentDownloadJob(id: string): Promise<void> {\n  return removeAttachmentDownloadJobSync(id);\n}\nasync function removeAllAttachmentDownloadJobs(): Promise<void> {\n  return removeAllFromTable(getInstance(), ATTACHMENT_DOWNLOADS_TABLE);\n}\n\n// Stickers\n\nasync function createOrUpdateStickerPack(pack: StickerPackType): Promise<void> {\n  const db = getInstance();\n  const {\n    attemptedStatus,\n    author,\n    coverStickerId,\n    createdAt,\n    downloadAttempts,\n    id,\n    installedAt,\n    key,\n    lastUsed,\n    status,\n    stickerCount,\n    title,\n    storageID,\n    storageVersion,\n    storageUnknownFields,\n    storageNeedsSync,\n  } = pack;\n  if (!id) {\n    throw new Error(\n      'createOrUpdateStickerPack: Provided data did not have a truthy id'\n    );\n  }\n\n  let { position } = pack;\n\n  // Assign default position\n  if (!isNumber(position)) {\n    position = db\n      .prepare<EmptyQuery>(\n        `\n        SELECT IFNULL(MAX(position) + 1, 0)\n        FROM sticker_packs\n        `\n      )\n      .pluck()\n      .get();\n  }\n\n  const row = db\n    .prepare<Query>(\n      `\n      SELECT id\n      FROM sticker_packs\n      WHERE id = $id;\n      `\n    )\n    .get({ id });\n  const payload = {\n    attemptedStatus: attemptedStatus ?? null,\n    author,\n    coverStickerId,\n    createdAt: createdAt || Date.now(),\n    downloadAttempts: downloadAttempts || 1,\n    id,\n    installedAt: installedAt ?? null,\n    key,\n    lastUsed: lastUsed || null,\n    status,\n    stickerCount,\n    title,\n    position: position ?? 0,\n    storageID: storageID ?? null,\n    storageVersion: storageVersion ?? null,\n    storageUnknownFields: storageUnknownFields ?? null,\n    storageNeedsSync: storageNeedsSync ? 1 : 0,\n  };\n\n  if (row) {\n    db.prepare<Query>(\n      `\n      UPDATE sticker_packs SET\n        attemptedStatus = $attemptedStatus,\n        author = $author,\n        coverStickerId = $coverStickerId,\n        createdAt = $createdAt,\n        downloadAttempts = $downloadAttempts,\n        installedAt = $installedAt,\n        key = $key,\n        lastUsed = $lastUsed,\n        status = $status,\n        stickerCount = $stickerCount,\n        title = $title,\n        position = $position,\n        storageID = $storageID,\n        storageVersion = $storageVersion,\n        storageUnknownFields = $storageUnknownFields,\n        storageNeedsSync = $storageNeedsSync\n      WHERE id = $id;\n      `\n    ).run(payload);\n\n    return;\n  }\n\n  db.prepare<Query>(\n    `\n    INSERT INTO sticker_packs (\n      attemptedStatus,\n      author,\n      coverStickerId,\n      createdAt,\n      downloadAttempts,\n      id,\n      installedAt,\n      key,\n      lastUsed,\n      status,\n      stickerCount,\n      title,\n      position,\n      storageID,\n      storageVersion,\n      storageUnknownFields,\n      storageNeedsSync\n    ) values (\n      $attemptedStatus,\n      $author,\n      $coverStickerId,\n      $createdAt,\n      $downloadAttempts,\n      $id,\n      $installedAt,\n      $key,\n      $lastUsed,\n      $status,\n      $stickerCount,\n      $title,\n      $position,\n      $storageID,\n      $storageVersion,\n      $storageUnknownFields,\n      $storageNeedsSync\n    )\n    `\n  ).run(payload);\n}\nfunction updateStickerPackStatusSync(\n  id: string,\n  status: StickerPackStatusType,\n  options?: { timestamp: number }\n): void {\n  const db = getInstance();\n  const timestamp = options ? options.timestamp || Date.now() : Date.now();\n  const installedAt = status === 'installed' ? timestamp : null;\n\n  db.prepare<Query>(\n    `\n    UPDATE sticker_packs\n    SET status = $status, installedAt = $installedAt\n    WHERE id = $id;\n    `\n  ).run({\n    id,\n    status,\n    installedAt,\n  });\n}\nasync function updateStickerPackStatus(\n  id: string,\n  status: StickerPackStatusType,\n  options?: { timestamp: number }\n): Promise<void> {\n  return updateStickerPackStatusSync(id, status, options);\n}\nasync function updateStickerPackInfo({\n  id,\n  storageID,\n  storageVersion,\n  storageUnknownFields,\n  storageNeedsSync,\n  uninstalledAt,\n}: StickerPackInfoType): Promise<void> {\n  const db = getInstance();\n\n  if (uninstalledAt) {\n    db.prepare<Query>(\n      `\n      UPDATE uninstalled_sticker_packs\n      SET\n        storageID = $storageID,\n        storageVersion = $storageVersion,\n        storageUnknownFields = $storageUnknownFields,\n        storageNeedsSync = $storageNeedsSync\n      WHERE id = $id;\n      `\n    ).run({\n      id,\n      storageID: storageID ?? null,\n      storageVersion: storageVersion ?? null,\n      storageUnknownFields: storageUnknownFields ?? null,\n      storageNeedsSync: storageNeedsSync ? 1 : 0,\n    });\n  } else {\n    db.prepare<Query>(\n      `\n      UPDATE sticker_packs\n      SET\n        storageID = $storageID,\n        storageVersion = $storageVersion,\n        storageUnknownFields = $storageUnknownFields,\n        storageNeedsSync = $storageNeedsSync\n      WHERE id = $id;\n      `\n    ).run({\n      id,\n      storageID: storageID ?? null,\n      storageVersion: storageVersion ?? null,\n      storageUnknownFields: storageUnknownFields ?? null,\n      storageNeedsSync: storageNeedsSync ? 1 : 0,\n    });\n  }\n}\nasync function clearAllErrorStickerPackAttempts(): Promise<void> {\n  const db = getInstance();\n\n  db.prepare<EmptyQuery>(\n    `\n    UPDATE sticker_packs\n    SET downloadAttempts = 0\n    WHERE status = 'error';\n    `\n  ).run();\n}\nasync function createOrUpdateSticker(sticker: StickerType): Promise<void> {\n  const db = getInstance();\n  const { emoji, height, id, isCoverOnly, lastUsed, packId, path, width } =\n    sticker;\n\n  if (!isNumber(id)) {\n    throw new Error(\n      'createOrUpdateSticker: Provided data did not have a numeric id'\n    );\n  }\n  if (!packId) {\n    throw new Error(\n      'createOrUpdateSticker: Provided data did not have a truthy id'\n    );\n  }\n\n  db.prepare<Query>(\n    `\n    INSERT OR REPLACE INTO stickers (\n      emoji,\n      height,\n      id,\n      isCoverOnly,\n      lastUsed,\n      packId,\n      path,\n      width\n    ) values (\n      $emoji,\n      $height,\n      $id,\n      $isCoverOnly,\n      $lastUsed,\n      $packId,\n      $path,\n      $width\n    )\n    `\n  ).run({\n    emoji: emoji ?? null,\n    height,\n    id,\n    isCoverOnly: isCoverOnly ? 1 : 0,\n    lastUsed: lastUsed || null,\n    packId,\n    path,\n    width,\n  });\n}\nasync function updateStickerLastUsed(\n  packId: string,\n  stickerId: number,\n  lastUsed: number\n): Promise<void> {\n  const db = getInstance();\n  db.prepare<Query>(\n    `\n    UPDATE stickers\n    SET lastUsed = $lastUsed\n    WHERE id = $id AND packId = $packId;\n    `\n  ).run({\n    id: stickerId,\n    packId,\n    lastUsed,\n  });\n  db.prepare<Query>(\n    `\n    UPDATE sticker_packs\n    SET lastUsed = $lastUsed\n    WHERE id = $id;\n    `\n  ).run({\n    id: packId,\n    lastUsed,\n  });\n}\nasync function addStickerPackReference(\n  messageId: string,\n  packId: string\n): Promise<void> {\n  const db = getInstance();\n\n  if (!messageId) {\n    throw new Error(\n      'addStickerPackReference: Provided data did not have a truthy messageId'\n    );\n  }\n  if (!packId) {\n    throw new Error(\n      'addStickerPackReference: Provided data did not have a truthy packId'\n    );\n  }\n\n  db.prepare<Query>(\n    `\n    INSERT OR REPLACE INTO sticker_references (\n      messageId,\n      packId\n    ) values (\n      $messageId,\n      $packId\n    )\n    `\n  ).run({\n    messageId,\n    packId,\n  });\n}\nasync function deleteStickerPackReference(\n  messageId: string,\n  packId: string\n): Promise<ReadonlyArray<string> | undefined> {\n  const db = getInstance();\n\n  if (!messageId) {\n    throw new Error(\n      'addStickerPackReference: Provided data did not have a truthy messageId'\n    );\n  }\n  if (!packId) {\n    throw new Error(\n      'addStickerPackReference: Provided data did not have a truthy packId'\n    );\n  }\n\n  return db\n    .transaction(() => {\n      // We use an immediate transaction here to immediately acquire an exclusive lock,\n      //   which would normally only happen when we did our first write.\n\n      // We need this to ensure that our five queries are all atomic, with no\n      // other changes happening while we do it:\n      // 1. Delete our target messageId/packId references\n      // 2. Check the number of references still pointing at packId\n      // 3. If that number is zero, get pack from sticker_packs database\n      // 4. If it's not installed, then grab all of its sticker paths\n      // 5. If it's not installed, then sticker pack (which cascades to all\n      //    stickers and references)\n      db.prepare<Query>(\n        `\n        DELETE FROM sticker_references\n        WHERE messageId = $messageId AND packId = $packId;\n        `\n      ).run({\n        messageId,\n        packId,\n      });\n\n      const count = db\n        .prepare<Query>(\n          `\n          SELECT count(1) FROM sticker_references\n          WHERE packId = $packId;\n          `\n        )\n        .pluck()\n        .get({ packId });\n      if (count > 0) {\n        return undefined;\n      }\n\n      const packRow: { status: StickerPackStatusType } = db\n        .prepare<Query>(\n          `\n          SELECT status FROM sticker_packs\n          WHERE id = $packId;\n          `\n        )\n        .get({ packId });\n      if (!packRow) {\n        logger.warn('deleteStickerPackReference: did not find referenced pack');\n        return undefined;\n      }\n      const { status } = packRow;\n\n      if (status === 'installed') {\n        return undefined;\n      }\n\n      const stickerPathRows: Array<{ path: string }> = db\n        .prepare<Query>(\n          `\n          SELECT path FROM stickers\n          WHERE packId = $packId;\n          `\n        )\n        .all({\n          packId,\n        });\n      db.prepare<Query>(\n        `\n        DELETE FROM sticker_packs\n        WHERE id = $packId;\n        `\n      ).run({\n        packId,\n      });\n\n      return (stickerPathRows || []).map(row => row.path);\n    })\n    .immediate();\n}\n\nasync function deleteStickerPack(packId: string): Promise<Array<string>> {\n  const db = getInstance();\n\n  if (!packId) {\n    throw new Error(\n      'deleteStickerPack: Provided data did not have a truthy packId'\n    );\n  }\n\n  return db\n    .transaction(() => {\n      // We use an immediate transaction here to immediately acquire an exclusive lock,\n      //   which would normally only happen when we did our first write.\n\n      // We need this to ensure that our two queries are atomic, with no other changes\n      //   happening while we do it:\n      // 1. Grab all of target pack's sticker paths\n      // 2. Delete sticker pack (which cascades to all stickers and references)\n\n      const stickerPathRows: Array<{ path: string }> = db\n        .prepare<Query>(\n          `\n          SELECT path FROM stickers\n          WHERE packId = $packId;\n          `\n        )\n        .all({\n          packId,\n        });\n      db.prepare<Query>(\n        `\n        DELETE FROM sticker_packs\n        WHERE id = $packId;\n        `\n      ).run({ packId });\n\n      return (stickerPathRows || []).map(row => row.path);\n    })\n    .immediate();\n}\n\nasync function getStickerCount(): Promise<number> {\n  return getCountFromTable(getInstance(), 'stickers');\n}\nasync function getAllStickerPacks(): Promise<Array<StickerPackType>> {\n  const db = getInstance();\n\n  const rows = db\n    .prepare<EmptyQuery>(\n      `\n      SELECT * FROM sticker_packs\n      ORDER BY position ASC, id ASC\n      `\n    )\n    .all();\n\n  return rows || [];\n}\nfunction addUninstalledStickerPackSync(pack: UninstalledStickerPackType): void {\n  const db = getInstance();\n\n  db.prepare<Query>(\n    `\n        INSERT OR REPLACE INTO uninstalled_sticker_packs\n        (\n          id, uninstalledAt, storageID, storageVersion, storageUnknownFields,\n          storageNeedsSync\n        )\n        VALUES\n        (\n          $id, $uninstalledAt, $storageID, $storageVersion, $unknownFields,\n          $storageNeedsSync\n        )\n      `\n  ).run({\n    id: pack.id,\n    uninstalledAt: pack.uninstalledAt,\n    storageID: pack.storageID ?? null,\n    storageVersion: pack.storageVersion ?? null,\n    unknownFields: pack.storageUnknownFields ?? null,\n    storageNeedsSync: pack.storageNeedsSync ? 1 : 0,\n  });\n}\nasync function addUninstalledStickerPack(\n  pack: UninstalledStickerPackType\n): Promise<void> {\n  return addUninstalledStickerPackSync(pack);\n}\nfunction removeUninstalledStickerPackSync(packId: string): void {\n  const db = getInstance();\n\n  db.prepare<Query>(\n    'DELETE FROM uninstalled_sticker_packs WHERE id IS $id'\n  ).run({ id: packId });\n}\nasync function removeUninstalledStickerPack(packId: string): Promise<void> {\n  return removeUninstalledStickerPackSync(packId);\n}\nasync function getUninstalledStickerPacks(): Promise<\n  Array<UninstalledStickerPackType>\n> {\n  const db = getInstance();\n\n  const rows = db\n    .prepare<EmptyQuery>(\n      'SELECT * FROM uninstalled_sticker_packs ORDER BY id ASC'\n    )\n    .all();\n\n  return rows || [];\n}\nasync function getInstalledStickerPacks(): Promise<Array<StickerPackType>> {\n  const db = getInstance();\n\n  // If sticker pack has a storageID - it is being downloaded and about to be\n  // installed so we better sync it back to storage service if asked.\n  const rows = db\n    .prepare<EmptyQuery>(\n      `\n      SELECT *\n      FROM sticker_packs\n      WHERE\n        status IS 'installed' OR\n        storageID IS NOT NULL\n      ORDER BY id ASC\n      `\n    )\n    .all();\n\n  return rows || [];\n}\nasync function getStickerPackInfo(\n  packId: string\n): Promise<StickerPackInfoType | undefined> {\n  const db = getInstance();\n\n  return db.transaction(() => {\n    const uninstalled = db\n      .prepare<Query>(\n        `\n        SELECT * FROM uninstalled_sticker_packs\n        WHERE id IS $packId\n        `\n      )\n      .get({ packId });\n    if (uninstalled) {\n      return uninstalled as UninstalledStickerPackType;\n    }\n\n    const installed = db\n      .prepare<Query>(\n        `\n        SELECT\n          id, key, position, storageID, storageVersion, storageUnknownFields\n        FROM sticker_packs\n        WHERE id IS $packId\n        `\n      )\n      .get({ packId });\n    if (installed) {\n      return installed as InstalledStickerPackType;\n    }\n\n    return undefined;\n  })();\n}\nasync function installStickerPack(\n  packId: string,\n  timestamp: number\n): Promise<void> {\n  const db = getInstance();\n  return db.transaction(() => {\n    const status = 'installed';\n    updateStickerPackStatusSync(packId, status, { timestamp });\n\n    removeUninstalledStickerPackSync(packId);\n  })();\n}\nasync function uninstallStickerPack(\n  packId: string,\n  timestamp: number\n): Promise<void> {\n  const db = getInstance();\n  return db.transaction(() => {\n    const status = 'downloaded';\n    updateStickerPackStatusSync(packId, status);\n\n    db.prepare<Query>(\n      `\n      UPDATE sticker_packs SET\n        storageID = NULL,\n        storageVersion = NULL,\n        storageUnknownFields = NULL,\n        storageNeedsSync = 0\n      WHERE id = $packId;\n      `\n    ).run({ packId });\n\n    addUninstalledStickerPackSync({\n      id: packId,\n      uninstalledAt: timestamp,\n      storageNeedsSync: true,\n    });\n  })();\n}\nasync function getAllStickers(): Promise<Array<StickerType>> {\n  const db = getInstance();\n\n  const rows = db\n    .prepare<EmptyQuery>(\n      `\n      SELECT * FROM stickers\n      ORDER BY packId ASC, id ASC\n      `\n    )\n    .all();\n\n  return (rows || []).map(row => rowToSticker(row));\n}\nasync function getRecentStickers({ limit }: { limit?: number } = {}): Promise<\n  Array<StickerType>\n> {\n  const db = getInstance();\n\n  // Note: we avoid 'IS NOT NULL' here because it does seem to bypass our index\n  const rows = db\n    .prepare<Query>(\n      `\n      SELECT stickers.* FROM stickers\n      JOIN sticker_packs on stickers.packId = sticker_packs.id\n      WHERE stickers.lastUsed > 0 AND sticker_packs.status = 'installed'\n      ORDER BY stickers.lastUsed DESC\n      LIMIT $limit\n      `\n    )\n    .all({\n      limit: limit || 24,\n    });\n\n  return (rows || []).map(row => rowToSticker(row));\n}\n\n// Emojis\nasync function updateEmojiUsage(\n  shortName: string,\n  timeUsed: number = Date.now()\n): Promise<void> {\n  const db = getInstance();\n\n  db.transaction(() => {\n    const rows = db\n      .prepare<Query>(\n        `\n        SELECT * FROM emojis\n        WHERE shortName = $shortName;\n        `\n      )\n      .get({\n        shortName,\n      });\n\n    if (rows) {\n      db.prepare<Query>(\n        `\n        UPDATE emojis\n        SET lastUsage = $timeUsed\n        WHERE shortName = $shortName;\n        `\n      ).run({ shortName, timeUsed });\n    } else {\n      db.prepare<Query>(\n        `\n        INSERT INTO emojis(shortName, lastUsage)\n        VALUES ($shortName, $timeUsed);\n        `\n      ).run({ shortName, timeUsed });\n    }\n  })();\n}\n\nasync function getRecentEmojis(limit = 32): Promise<Array<EmojiType>> {\n  const db = getInstance();\n  const rows = db\n    .prepare<Query>(\n      `\n      SELECT *\n      FROM emojis\n      ORDER BY lastUsage DESC\n      LIMIT $limit;\n      `\n    )\n    .all({ limit });\n\n  return rows || [];\n}\n\nasync function getAllBadges(): Promise<Array<BadgeType>> {\n  const db = getInstance();\n\n  const [badgeRows, badgeImageFileRows] = db.transaction(() => [\n    db.prepare<EmptyQuery>('SELECT * FROM badges').all(),\n    db.prepare<EmptyQuery>('SELECT * FROM badgeImageFiles').all(),\n  ])();\n\n  const badgeImagesByBadge = new Map<\n    string,\n    Array<undefined | BadgeImageType>\n  >();\n  for (const badgeImageFileRow of badgeImageFileRows) {\n    const { badgeId, order, localPath, url, theme } = badgeImageFileRow;\n    const badgeImages = badgeImagesByBadge.get(badgeId) || [];\n    badgeImages[order] = {\n      ...(badgeImages[order] || {}),\n      [parseBadgeImageTheme(theme)]: {\n        localPath: dropNull(localPath),\n        url,\n      },\n    };\n    badgeImagesByBadge.set(badgeId, badgeImages);\n  }\n\n  return badgeRows.map(badgeRow => ({\n    id: badgeRow.id,\n    category: parseBadgeCategory(badgeRow.category),\n    name: badgeRow.name,\n    descriptionTemplate: badgeRow.descriptionTemplate,\n    images: (badgeImagesByBadge.get(badgeRow.id) || []).filter(isNotNil),\n  }));\n}\n\n// This should match the logic in the badges Redux reducer.\nasync function updateOrCreateBadges(\n  badges: ReadonlyArray<BadgeType>\n): Promise<void> {\n  const db = getInstance();\n\n  const insertBadge = prepare<Query>(\n    db,\n    `\n    INSERT OR REPLACE INTO badges (\n      id,\n      category,\n      name,\n      descriptionTemplate\n    ) VALUES (\n      $id,\n      $category,\n      $name,\n      $descriptionTemplate\n    );\n    `\n  );\n  const getImageFilesForBadge = prepare<Query>(\n    db,\n    'SELECT url, localPath FROM badgeImageFiles WHERE badgeId = $badgeId'\n  );\n  const insertBadgeImageFile = prepare<Query>(\n    db,\n    `\n    INSERT INTO badgeImageFiles (\n      badgeId,\n      'order',\n      url,\n      localPath,\n      theme\n    ) VALUES (\n      $badgeId,\n      $order,\n      $url,\n      $localPath,\n      $theme\n    );\n    `\n  );\n\n  db.transaction(() => {\n    badges.forEach(badge => {\n      const { id: badgeId } = badge;\n\n      const oldLocalPaths = new Map<string, string>();\n      for (const { url, localPath } of getImageFilesForBadge.all({ badgeId })) {\n        if (localPath) {\n          oldLocalPaths.set(url, localPath);\n        }\n      }\n\n      insertBadge.run({\n        id: badgeId,\n        category: badge.category,\n        name: badge.name,\n        descriptionTemplate: badge.descriptionTemplate,\n      });\n\n      for (const [order, image] of badge.images.entries()) {\n        for (const [theme, imageFile] of Object.entries(image)) {\n          insertBadgeImageFile.run({\n            badgeId,\n            localPath:\n              imageFile.localPath || oldLocalPaths.get(imageFile.url) || null,\n            order,\n            theme,\n            url: imageFile.url,\n          });\n        }\n      }\n    });\n  })();\n}\n\nasync function badgeImageFileDownloaded(\n  url: string,\n  localPath: string\n): Promise<void> {\n  const db = getInstance();\n  prepare<Query>(\n    db,\n    'UPDATE badgeImageFiles SET localPath = $localPath WHERE url = $url'\n  ).run({ url, localPath });\n}\n\nasync function getAllBadgeImageFileLocalPaths(): Promise<Set<string>> {\n  const db = getInstance();\n  const localPaths = db\n    .prepare<EmptyQuery>(\n      'SELECT localPath FROM badgeImageFiles WHERE localPath IS NOT NULL'\n    )\n    .pluck()\n    .all();\n  return new Set(localPaths);\n}\n\ntype StoryDistributionForDatabase = Readonly<\n  {\n    allowsReplies: 0 | 1;\n    deletedAtTimestamp: number | null;\n    isBlockList: 0 | 1;\n    senderKeyInfoJson: string | null;\n    storageID: string | null;\n    storageVersion: number | null;\n    storageNeedsSync: 0 | 1;\n  } & Omit<\n    StoryDistributionType,\n    | 'allowsReplies'\n    | 'deletedAtTimestamp'\n    | 'isBlockList'\n    | 'senderKeyInfo'\n    | 'storageID'\n    | 'storageVersion'\n    | 'storageNeedsSync'\n  >\n>;\n\nfunction hydrateStoryDistribution(\n  fromDatabase: StoryDistributionForDatabase\n): StoryDistributionType {\n  return {\n    ...omit(fromDatabase, 'senderKeyInfoJson'),\n    allowsReplies: Boolean(fromDatabase.allowsReplies),\n    deletedAtTimestamp: fromDatabase.deletedAtTimestamp || undefined,\n    isBlockList: Boolean(fromDatabase.isBlockList),\n    senderKeyInfo: fromDatabase.senderKeyInfoJson\n      ? JSON.parse(fromDatabase.senderKeyInfoJson)\n      : undefined,\n    storageID: fromDatabase.storageID || undefined,\n    storageVersion: fromDatabase.storageVersion || undefined,\n    storageNeedsSync: Boolean(fromDatabase.storageNeedsSync),\n    storageUnknownFields: fromDatabase.storageUnknownFields || undefined,\n  };\n}\nfunction freezeStoryDistribution(\n  story: StoryDistributionType\n): StoryDistributionForDatabase {\n  return {\n    ...omit(story, 'senderKeyInfo'),\n    allowsReplies: story.allowsReplies ? 1 : 0,\n    deletedAtTimestamp: story.deletedAtTimestamp || null,\n    isBlockList: story.isBlockList ? 1 : 0,\n    senderKeyInfoJson: story.senderKeyInfo\n      ? JSON.stringify(story.senderKeyInfo)\n      : null,\n    storageID: story.storageID || null,\n    storageVersion: story.storageVersion || null,\n    storageNeedsSync: story.storageNeedsSync ? 1 : 0,\n    storageUnknownFields: story.storageUnknownFields || null,\n  };\n}\n\nasync function _getAllStoryDistributions(): Promise<\n  Array<StoryDistributionType>\n> {\n  const db = getInstance();\n  const storyDistributions = db\n    .prepare<EmptyQuery>('SELECT * FROM storyDistributions;')\n    .all();\n\n  return storyDistributions.map(hydrateStoryDistribution);\n}\nasync function _getAllStoryDistributionMembers(): Promise<\n  Array<StoryDistributionMemberType>\n> {\n  const db = getInstance();\n  return db\n    .prepare<EmptyQuery>('SELECT * FROM storyDistributionMembers;')\n    .all();\n}\nasync function _deleteAllStoryDistributions(): Promise<void> {\n  const db = getInstance();\n  db.prepare<EmptyQuery>('DELETE FROM storyDistributions;').run();\n}\nasync function createNewStoryDistribution(\n  distribution: StoryDistributionWithMembersType\n): Promise<void> {\n  strictAssert(\n    distribution.name,\n    'Distribution list does not have a valid name'\n  );\n\n  const db = getInstance();\n\n  db.transaction(() => {\n    const payload = freezeStoryDistribution(distribution);\n\n    prepare(\n      db,\n      `\n      INSERT INTO storyDistributions(\n        id,\n        name,\n        deletedAtTimestamp,\n        allowsReplies,\n        isBlockList,\n        senderKeyInfoJson,\n        storageID,\n        storageVersion,\n        storageUnknownFields,\n        storageNeedsSync\n      ) VALUES (\n        $id,\n        $name,\n        $deletedAtTimestamp,\n        $allowsReplies,\n        $isBlockList,\n        $senderKeyInfoJson,\n        $storageID,\n        $storageVersion,\n        $storageUnknownFields,\n        $storageNeedsSync\n      );\n      `\n    ).run(payload);\n\n    const { id: listId, members } = distribution;\n\n    const memberInsertStatement = prepare(\n      db,\n      `\n      INSERT OR REPLACE INTO storyDistributionMembers (\n        listId,\n        uuid\n      ) VALUES (\n        $listId,\n        $uuid\n      );\n      `\n    );\n\n    for (const uuid of members) {\n      memberInsertStatement.run({\n        listId,\n        uuid,\n      });\n    }\n  })();\n}\nasync function getAllStoryDistributionsWithMembers(): Promise<\n  Array<StoryDistributionWithMembersType>\n> {\n  const allDistributions = await _getAllStoryDistributions();\n  const allMembers = await _getAllStoryDistributionMembers();\n\n  const byListId = groupBy(allMembers, member => member.listId);\n\n  return allDistributions.map(list => ({\n    ...list,\n    members: (byListId[list.id] || []).map(member => member.uuid),\n  }));\n}\nasync function getStoryDistributionWithMembers(\n  id: string\n): Promise<StoryDistributionWithMembersType | undefined> {\n  const db = getInstance();\n  const storyDistribution: StoryDistributionForDatabase | undefined = prepare(\n    db,\n    'SELECT * FROM storyDistributions WHERE id = $id;'\n  ).get({\n    id,\n  });\n\n  if (!storyDistribution) {\n    return undefined;\n  }\n\n  const members = prepare(\n    db,\n    'SELECT * FROM storyDistributionMembers WHERE listId = $id;'\n  ).all({\n    id,\n  });\n\n  return {\n    ...hydrateStoryDistribution(storyDistribution),\n    members: members.map(({ uuid }) => uuid),\n  };\n}\nfunction modifyStoryDistributionSync(\n  db: Database,\n  payload: StoryDistributionForDatabase\n): void {\n  if (payload.deletedAtTimestamp) {\n    strictAssert(\n      !payload.name,\n      'Attempt to delete distribution list but still has a name'\n    );\n  } else {\n    strictAssert(\n      payload.name,\n      'Cannot clear distribution list name without deletedAtTimestamp set'\n    );\n  }\n\n  prepare(\n    db,\n    `\n    UPDATE storyDistributions\n    SET\n      name = $name,\n      deletedAtTimestamp = $deletedAtTimestamp,\n      allowsReplies = $allowsReplies,\n      isBlockList = $isBlockList,\n      senderKeyInfoJson = $senderKeyInfoJson,\n      storageID = $storageID,\n      storageVersion = $storageVersion,\n      storageUnknownFields = $storageUnknownFields,\n      storageNeedsSync = $storageNeedsSync\n    WHERE id = $id\n    `\n  ).run(payload);\n}\nfunction modifyStoryDistributionMembersSync(\n  db: Database,\n  listId: string,\n  {\n    toAdd,\n    toRemove,\n  }: { toAdd: Array<UUIDStringType>; toRemove: Array<UUIDStringType> }\n) {\n  const memberInsertStatement = prepare(\n    db,\n    `\n    INSERT OR REPLACE INTO storyDistributionMembers (\n      listId,\n      uuid\n    ) VALUES (\n      $listId,\n      $uuid\n    );\n    `\n  );\n\n  for (const uuid of toAdd) {\n    memberInsertStatement.run({\n      listId,\n      uuid,\n    });\n  }\n\n  batchMultiVarQuery(db, toRemove, (uuids: ReadonlyArray<UUIDStringType>) => {\n    db.prepare<ArrayQuery>(\n      `\n      DELETE FROM storyDistributionMembers\n      WHERE listId = ? AND uuid IN ( ${uuids.map(() => '?').join(', ')} );\n      `\n    ).run([listId, ...uuids]);\n  });\n}\nasync function modifyStoryDistributionWithMembers(\n  distribution: StoryDistributionType,\n  {\n    toAdd,\n    toRemove,\n  }: { toAdd: Array<UUIDStringType>; toRemove: Array<UUIDStringType> }\n): Promise<void> {\n  const payload = freezeStoryDistribution(distribution);\n  const db = getInstance();\n\n  if (toAdd.length || toRemove.length) {\n    db.transaction(() => {\n      modifyStoryDistributionSync(db, payload);\n      modifyStoryDistributionMembersSync(db, payload.id, { toAdd, toRemove });\n    })();\n  } else {\n    modifyStoryDistributionSync(db, payload);\n  }\n}\nasync function modifyStoryDistribution(\n  distribution: StoryDistributionType\n): Promise<void> {\n  const payload = freezeStoryDistribution(distribution);\n  const db = getInstance();\n  modifyStoryDistributionSync(db, payload);\n}\nasync function modifyStoryDistributionMembers(\n  listId: string,\n  {\n    toAdd,\n    toRemove,\n  }: { toAdd: Array<UUIDStringType>; toRemove: Array<UUIDStringType> }\n): Promise<void> {\n  const db = getInstance();\n\n  db.transaction(() => {\n    modifyStoryDistributionMembersSync(db, listId, { toAdd, toRemove });\n  })();\n}\nasync function deleteStoryDistribution(id: UUIDStringType): Promise<void> {\n  const db = getInstance();\n  db.prepare<Query>('DELETE FROM storyDistributions WHERE id = $id;').run({\n    id,\n  });\n}\n\nasync function _getAllStoryReads(): Promise<Array<StoryReadType>> {\n  const db = getInstance();\n  return db.prepare<EmptyQuery>('SELECT * FROM storyReads;').all();\n}\nasync function _deleteAllStoryReads(): Promise<void> {\n  const db = getInstance();\n  db.prepare<EmptyQuery>('DELETE FROM storyReads;').run();\n}\nasync function addNewStoryRead(read: StoryReadType): Promise<void> {\n  const db = getInstance();\n\n  prepare(\n    db,\n    `\n    INSERT OR REPLACE INTO storyReads(\n      authorId,\n      conversationId,\n      storyId,\n      storyReadDate\n    ) VALUES (\n      $authorId,\n      $conversationId,\n      $storyId,\n      $storyReadDate\n    );\n    `\n  ).run(read);\n}\nasync function getLastStoryReadsForAuthor({\n  authorId,\n  conversationId,\n  limit: initialLimit,\n}: {\n  authorId: UUIDStringType;\n  conversationId?: UUIDStringType;\n  limit?: number;\n}): Promise<Array<StoryReadType>> {\n  const limit = initialLimit || 5;\n\n  const db = getInstance();\n  return db\n    .prepare<Query>(\n      `\n      SELECT * FROM storyReads\n      WHERE\n        authorId = $authorId AND\n        ($conversationId IS NULL OR conversationId = $conversationId)\n      ORDER BY storyReadDate DESC\n      LIMIT $limit;\n      `\n    )\n    .all({\n      authorId,\n      conversationId: conversationId || null,\n      limit,\n    });\n}\n\nasync function countStoryReadsByConversation(\n  conversationId: string\n): Promise<number> {\n  const db = getInstance();\n  return db\n    .prepare<Query>(\n      `\n      SELECT count(1) FROM storyReads\n      WHERE conversationId = $conversationId;\n      `\n    )\n    .pluck()\n    .get({ conversationId });\n}\n\n// All data in database\nasync function removeAll(): Promise<void> {\n  const db = getInstance();\n\n  db.transaction(() => {\n    db.exec(`\n      DELETE FROM attachment_downloads;\n      DELETE FROM badgeImageFiles;\n      DELETE FROM badges;\n      DELETE FROM conversations;\n      DELETE FROM emojis;\n      DELETE FROM groupCallRingCancellations;\n      DELETE FROM identityKeys;\n      DELETE FROM items;\n      DELETE FROM jobs;\n      DELETE FROM messages_fts;\n      DELETE FROM messages;\n      DELETE FROM preKeys;\n      DELETE FROM reactions;\n      DELETE FROM senderKeys;\n      DELETE FROM sendLogMessageIds;\n      DELETE FROM sendLogPayloads;\n      DELETE FROM sendLogRecipients;\n      DELETE FROM sessions;\n      DELETE FROM signedPreKeys;\n      DELETE FROM sticker_packs;\n      DELETE FROM sticker_references;\n      DELETE FROM stickers;\n      DELETE FROM storyDistributionMembers;\n      DELETE FROM storyDistributions;\n      DELETE FROM storyReads;\n      DELETE FROM unprocessed;\n      DELETE FROM uninstalled_sticker_packs;\n\n      INSERT INTO messages_fts(messages_fts) VALUES('optimize');\n    `);\n  })();\n}\n\n// Anything that isn't user-visible data\nasync function removeAllConfiguration(\n  mode = RemoveAllConfiguration.Full\n): Promise<void> {\n  const db = getInstance();\n\n  db.transaction(() => {\n    db.exec(\n      `\n      DELETE FROM identityKeys;\n      DELETE FROM jobs;\n      DELETE FROM preKeys;\n      DELETE FROM senderKeys;\n      DELETE FROM sendLogMessageIds;\n      DELETE FROM sendLogPayloads;\n      DELETE FROM sendLogRecipients;\n      DELETE FROM sessions;\n      DELETE FROM signedPreKeys;\n      DELETE FROM unprocessed;\n      `\n    );\n\n    if (mode === RemoveAllConfiguration.Full) {\n      db.exec(\n        `\n        DELETE FROM items;\n        `\n      );\n    } else if (mode === RemoveAllConfiguration.Soft) {\n      const itemIds: ReadonlyArray<string> = db\n        .prepare<EmptyQuery>('SELECT id FROM items')\n        .pluck(true)\n        .all();\n\n      const allowedSet = new Set<string>(STORAGE_UI_KEYS);\n      for (const id of itemIds) {\n        if (!allowedSet.has(id)) {\n          removeById(db, 'items', id);\n        }\n      }\n    } else {\n      throw missingCaseError(mode);\n    }\n\n    db.exec(\n      \"UPDATE conversations SET json = json_remove(json, '$.senderKeyInfo');\"\n    );\n  })();\n}\n\nconst MAX_MESSAGE_MIGRATION_ATTEMPTS = 5;\n\nasync function getMessagesNeedingUpgrade(\n  limit: number,\n  { maxVersion }: { maxVersion: number }\n): Promise<Array<MessageType>> {\n  const db = getInstance();\n\n  const rows: JSONRows = db\n    .prepare<Query>(\n      `\n      SELECT json\n      FROM messages\n      WHERE\n        (schemaVersion IS NULL OR schemaVersion < $maxVersion) AND\n        IFNULL(\n          json_extract(json, '$.schemaMigrationAttempts'),\n          0\n        ) < $maxAttempts\n      LIMIT $limit;\n      `\n    )\n    .all({\n      maxVersion,\n      maxAttempts: MAX_MESSAGE_MIGRATION_ATTEMPTS,\n      limit,\n    });\n\n  return rows.map(row => jsonToObject(row.json));\n}\n\nasync function getMessagesWithVisualMediaAttachments(\n  conversationId: string,\n  { limit }: { limit: number }\n): Promise<Array<MessageType>> {\n  const db = getInstance();\n  const rows: JSONRows = db\n    .prepare<Query>(\n      `\n      SELECT json FROM messages\n      INDEXED BY messages_hasVisualMediaAttachments\n      WHERE\n        isStory IS 0 AND\n        storyId IS NULL AND\n        conversationId = $conversationId AND\n        -- Note that this check has to use 'IS' to utilize\n        -- 'messages_hasVisualMediaAttachments' INDEX\n        hasVisualMediaAttachments IS 1\n      ORDER BY received_at DESC, sent_at DESC\n      LIMIT $limit;\n      `\n    )\n    .all({\n      conversationId,\n      limit,\n    });\n\n  return rows.map(row => jsonToObject(row.json));\n}\n\nasync function getMessagesWithFileAttachments(\n  conversationId: string,\n  { limit }: { limit: number }\n): Promise<Array<MessageType>> {\n  const db = getInstance();\n  const rows = db\n    .prepare<Query>(\n      `\n      SELECT json FROM messages WHERE\n        isStory IS 0 AND\n        storyId IS NULL AND\n        conversationId = $conversationId AND\n        hasFileAttachments = 1\n      ORDER BY received_at DESC, sent_at DESC\n      LIMIT $limit;\n      `\n    )\n    .all({\n      conversationId,\n      limit,\n    });\n\n  return map(rows, row => jsonToObject(row.json));\n}\n\nasync function getMessageServerGuidsForSpam(\n  conversationId: string\n): Promise<Array<string>> {\n  const db = getInstance();\n\n  // The server's maximum is 3, which is why you see `LIMIT 3` in this query. Note that we\n  //   use `pluck` here to only get the first column!\n  return db\n    .prepare<Query>(\n      `\n      SELECT serverGuid\n      FROM messages\n      WHERE conversationId = $conversationId\n      AND type = 'incoming'\n      AND serverGuid IS NOT NULL\n      ORDER BY received_at DESC, sent_at DESC\n      LIMIT 3;\n      `\n    )\n    .pluck(true)\n    .all({ conversationId });\n}\n\nfunction getExternalFilesForMessage(message: MessageType): Array<string> {\n  const { attachments, contact, quote, preview, sticker } = message;\n  const files: Array<string> = [];\n\n  forEach(attachments, attachment => {\n    const { path: file, thumbnail, screenshot } = attachment;\n    if (file) {\n      files.push(file);\n    }\n\n    if (thumbnail && thumbnail.path) {\n      files.push(thumbnail.path);\n    }\n\n    if (screenshot && screenshot.path) {\n      files.push(screenshot.path);\n    }\n  });\n\n  if (quote && quote.attachments && quote.attachments.length) {\n    forEach(quote.attachments, attachment => {\n      const { thumbnail } = attachment;\n\n      if (thumbnail && thumbnail.path) {\n        files.push(thumbnail.path);\n      }\n    });\n  }\n\n  if (contact && contact.length) {\n    forEach(contact, item => {\n      const { avatar } = item;\n\n      if (avatar && avatar.avatar && avatar.avatar.path) {\n        files.push(avatar.avatar.path);\n      }\n    });\n  }\n\n  if (preview && preview.length) {\n    forEach(preview, item => {\n      const { image } = item;\n\n      if (image && image.path) {\n        files.push(image.path);\n      }\n    });\n  }\n\n  if (sticker && sticker.data && sticker.data.path) {\n    files.push(sticker.data.path);\n\n    if (sticker.data.thumbnail && sticker.data.thumbnail.path) {\n      files.push(sticker.data.thumbnail.path);\n    }\n  }\n\n  return files;\n}\n\nfunction getExternalFilesForConversation(\n  conversation: Pick<ConversationType, 'avatar' | 'profileAvatar'>\n): Array<string> {\n  const { avatar, profileAvatar } = conversation;\n  const files: Array<string> = [];\n\n  if (avatar && avatar.path) {\n    files.push(avatar.path);\n  }\n\n  if (profileAvatar && profileAvatar.path) {\n    files.push(profileAvatar.path);\n  }\n\n  return files;\n}\n\nfunction getExternalDraftFilesForConversation(\n  conversation: Pick<ConversationType, 'draftAttachments'>\n): Array<string> {\n  const draftAttachments = conversation.draftAttachments || [];\n  const files: Array<string> = [];\n\n  forEach(draftAttachments, attachment => {\n    if (attachment.pending) {\n      return;\n    }\n\n    const { path: file, screenshotPath } = attachment;\n    if (file) {\n      files.push(file);\n    }\n\n    if (screenshotPath) {\n      files.push(screenshotPath);\n    }\n  });\n\n  return files;\n}\n\nasync function getKnownMessageAttachments(\n  cursor?: MessageAttachmentsCursorType\n): Promise<GetKnownMessageAttachmentsResultType> {\n  const db = getInstance();\n  const result = new Set<string>();\n  const chunkSize = 1000;\n\n  return db.transaction(() => {\n    let count = cursor?.count ?? 0;\n\n    strictAssert(\n      !cursor?.done,\n      'getKnownMessageAttachments: iteration cannot be restarted'\n    );\n\n    let runId: string;\n    if (cursor === undefined) {\n      runId = randomBytes(8).toString('hex');\n\n      const total = getMessageCountSync();\n      logger.info(\n        `getKnownMessageAttachments(${runId}): ` +\n          `Starting iteration through ${total} messages`\n      );\n\n      db.exec(\n        `\n        CREATE TEMP TABLE tmp_${runId}_updated_messages\n          (rowid INTEGER PRIMARY KEY ASC);\n\n        INSERT INTO tmp_${runId}_updated_messages (rowid)\n        SELECT rowid FROM messages;\n\n        CREATE TEMP TRIGGER tmp_${runId}_message_updates\n        UPDATE OF json ON messages\n        BEGIN\n          INSERT OR IGNORE INTO tmp_${runId}_updated_messages (rowid)\n          VALUES (NEW.rowid);\n        END;\n\n        CREATE TEMP TRIGGER tmp_${runId}_message_inserts\n        AFTER INSERT ON messages\n        BEGIN\n          INSERT OR IGNORE INTO tmp_${runId}_updated_messages (rowid)\n          VALUES (NEW.rowid);\n        END;\n        `\n      );\n    } else {\n      ({ runId } = cursor);\n    }\n\n    const rowids: Array<number> = db\n      .prepare<Query>(\n        `\n      DELETE FROM tmp_${runId}_updated_messages\n      RETURNING rowid\n      LIMIT $chunkSize;\n      `\n      )\n      .pluck()\n      .all({ chunkSize });\n\n    const messages = batchMultiVarQuery(\n      db,\n      rowids,\n      (batch: ReadonlyArray<number>): Array<MessageType> => {\n        const query = db.prepare<ArrayQuery>(\n          `SELECT json FROM messages WHERE rowid IN (${Array(batch.length)\n            .fill('?')\n            .join(',')});`\n        );\n        const rows: JSONRows = query.all(batch);\n        return rows.map(row => jsonToObject(row.json));\n      }\n    );\n\n    for (const message of messages) {\n      const externalFiles = getExternalFilesForMessage(message);\n      forEach(externalFiles, file => result.add(file));\n      count += 1;\n    }\n\n    const done = rowids.length < chunkSize;\n    return {\n      attachments: Array.from(result),\n      cursor: { runId, count, done },\n    };\n  })();\n}\n\nasync function finishGetKnownMessageAttachments({\n  runId,\n  count,\n  done,\n}: MessageAttachmentsCursorType): Promise<void> {\n  const db = getInstance();\n\n  const logId = `finishGetKnownMessageAttachments(${runId})`;\n  if (!done) {\n    logger.warn(`${logId}: iteration not finished`);\n  }\n\n  logger.info(`${logId}: reached the end after processing ${count} messages`);\n  db.exec(`\n    DROP TABLE tmp_${runId}_updated_messages;\n    DROP TRIGGER tmp_${runId}_message_updates;\n    DROP TRIGGER tmp_${runId}_message_inserts;\n  `);\n}\n\nasync function getKnownConversationAttachments(): Promise<Array<string>> {\n  const db = getInstance();\n  const result = new Set<string>();\n  const chunkSize = 500;\n\n  let complete = false;\n  let id = '';\n\n  const conversationTotal = await getConversationCount();\n  logger.info(\n    'getKnownConversationAttachments: About to iterate through ' +\n      `${conversationTotal}`\n  );\n\n  const fetchConversations = db.prepare<Query>(\n    `\n      SELECT json FROM conversations\n      WHERE id > $id\n      ORDER BY id ASC\n      LIMIT $chunkSize;\n    `\n  );\n\n  while (!complete) {\n    const rows = fetchConversations.all({\n      id,\n      chunkSize,\n    });\n\n    const conversations: Array<ConversationType> = map(rows, row =>\n      jsonToObject(row.json)\n    );\n    conversations.forEach(conversation => {\n      const externalFiles = getExternalFilesForConversation(conversation);\n      externalFiles.forEach(file => result.add(file));\n    });\n\n    const lastMessage: ConversationType | undefined = last(conversations);\n    if (lastMessage) {\n      ({ id } = lastMessage);\n    }\n    complete = conversations.length < chunkSize;\n  }\n\n  logger.info('getKnownConversationAttachments: Done processing');\n\n  return Array.from(result);\n}\n\nasync function removeKnownStickers(\n  allStickers: ReadonlyArray<string>\n): Promise<Array<string>> {\n  const db = getInstance();\n  const lookup: Dictionary<boolean> = fromPairs(\n    map(allStickers, file => [file, true])\n  );\n  const chunkSize = 50;\n\n  const total = await getStickerCount();\n  logger.info(\n    `removeKnownStickers: About to iterate through ${total} stickers`\n  );\n\n  let count = 0;\n  let complete = false;\n  let rowid = 0;\n\n  while (!complete) {\n    const rows: Array<{ rowid: number; path: string }> = db\n      .prepare<Query>(\n        `\n        SELECT rowid, path FROM stickers\n        WHERE rowid > $rowid\n        ORDER BY rowid ASC\n        LIMIT $chunkSize;\n        `\n      )\n      .all({\n        rowid,\n        chunkSize,\n      });\n\n    const files: Array<string> = rows.map(row => row.path);\n    files.forEach(file => {\n      delete lookup[file];\n    });\n\n    const lastSticker = last(rows);\n    if (lastSticker) {\n      ({ rowid } = lastSticker);\n    }\n    complete = rows.length < chunkSize;\n    count += rows.length;\n  }\n\n  logger.info(`removeKnownStickers: Done processing ${count} stickers`);\n\n  return Object.keys(lookup);\n}\n\nasync function removeKnownDraftAttachments(\n  allStickers: ReadonlyArray<string>\n): Promise<Array<string>> {\n  const db = getInstance();\n  const lookup: Dictionary<boolean> = fromPairs(\n    map(allStickers, file => [file, true])\n  );\n  const chunkSize = 50;\n\n  const total = await getConversationCount();\n  logger.info(\n    `removeKnownDraftAttachments: About to iterate through ${total} conversations`\n  );\n\n  let complete = false;\n  let count = 0;\n  // Though conversations.id is a string, this ensures that, when coerced, this\n  //   value is still a string but it's smaller than every other string.\n  let id: number | string = 0;\n\n  while (!complete) {\n    const rows: JSONRows = db\n      .prepare<Query>(\n        `\n        SELECT json FROM conversations\n        WHERE id > $id\n        ORDER BY id ASC\n        LIMIT $chunkSize;\n        `\n      )\n      .all({\n        id,\n        chunkSize,\n      });\n\n    const conversations: Array<ConversationType> = rows.map(row =>\n      jsonToObject(row.json)\n    );\n    conversations.forEach(conversation => {\n      const externalFiles = getExternalDraftFilesForConversation(conversation);\n      externalFiles.forEach(file => {\n        delete lookup[file];\n      });\n    });\n\n    const lastMessage: ConversationType | undefined = last(conversations);\n    if (lastMessage) {\n      ({ id } = lastMessage);\n    }\n    complete = conversations.length < chunkSize;\n    count += conversations.length;\n  }\n\n  logger.info(\n    `removeKnownDraftAttachments: Done processing ${count} conversations`\n  );\n\n  return Object.keys(lookup);\n}\n\nconst OPTIMIZE_FTS_PAGE_COUNT = 64;\n\n// This query is incremental. It gets the `state` from the return value of\n// previous `optimizeFTS` call. When `state.done` is `true` - optimization is\n// complete.\nasync function optimizeFTS(\n  state?: FTSOptimizationStateType\n): Promise<FTSOptimizationStateType | undefined> {\n  // See https://www.sqlite.org/fts5.html#the_merge_command\n  let pageCount = OPTIMIZE_FTS_PAGE_COUNT;\n  if (state === undefined) {\n    pageCount = -pageCount;\n  }\n  const db = getInstance();\n  const getChanges = prepare(db, 'SELECT total_changes() as changes;', {\n    pluck: true,\n  });\n\n  const changeDifference = db.transaction(() => {\n    const before: number = getChanges.get({});\n\n    prepare(\n      db,\n      `\n        INSERT INTO messages_fts(messages_fts, rank) VALUES ('merge', $pageCount);\n      `\n    ).run({ pageCount });\n\n    const after: number = getChanges.get({});\n\n    return after - before;\n  })();\n\n  const nextSteps = (state?.steps ?? 0) + 1;\n\n  // From documentation:\n  // \"If the difference is less than 2, then the 'merge' command was a no-op\"\n  const done = changeDifference < 2;\n\n  return { steps: nextSteps, done };\n}\n\nasync function getJobsInQueue(queueType: string): Promise<Array<StoredJob>> {\n  const db = getInstance();\n  return getJobsInQueueSync(db, queueType);\n}\n\nexport function getJobsInQueueSync(\n  db: Database,\n  queueType: string\n): Array<StoredJob> {\n  return db\n    .prepare<Query>(\n      `\n      SELECT id, timestamp, data\n      FROM jobs\n      WHERE queueType = $queueType\n      ORDER BY timestamp;\n      `\n    )\n    .all({ queueType })\n    .map(row => ({\n      id: row.id,\n      queueType,\n      timestamp: row.timestamp,\n      data: isNotNil(row.data) ? JSON.parse(row.data) : undefined,\n    }));\n}\n\nexport function insertJobSync(db: Database, job: Readonly<StoredJob>): void {\n  db.prepare<Query>(\n    `\n      INSERT INTO jobs\n      (id, queueType, timestamp, data)\n      VALUES\n      ($id, $queueType, $timestamp, $data);\n    `\n  ).run({\n    id: job.id,\n    queueType: job.queueType,\n    timestamp: job.timestamp,\n    data: isNotNil(job.data) ? JSON.stringify(job.data) : null,\n  });\n}\n\nasync function insertJob(job: Readonly<StoredJob>): Promise<void> {\n  const db = getInstance();\n  return insertJobSync(db, job);\n}\n\nasync function deleteJob(id: string): Promise<void> {\n  const db = getInstance();\n\n  db.prepare<Query>('DELETE FROM jobs WHERE id = $id').run({ id });\n}\n\nasync function wasGroupCallRingPreviouslyCanceled(\n  ringId: bigint\n): Promise<boolean> {\n  const db = getInstance();\n\n  return db\n    .prepare<Query>(\n      `\n      SELECT EXISTS (\n        SELECT 1 FROM groupCallRingCancellations\n        WHERE ringId = $ringId\n        AND createdAt >= $ringsOlderThanThisAreIgnored\n      );\n      `\n    )\n    .pluck()\n    .get({\n      ringId,\n      ringsOlderThanThisAreIgnored: Date.now() - MAX_GROUP_CALL_RING_AGE,\n    });\n}\n\nasync function processGroupCallRingCancellation(ringId: bigint): Promise<void> {\n  const db = getInstance();\n\n  db.prepare<Query>(\n    `\n    INSERT INTO groupCallRingCancellations (ringId, createdAt)\n    VALUES ($ringId, $createdAt)\n    ON CONFLICT (ringId) DO NOTHING;\n    `\n  ).run({ ringId, createdAt: Date.now() });\n}\n\n// This age, in milliseconds, should be longer than any group call ring duration. Beyond\n//   that, it doesn't really matter what the value is.\nconst MAX_GROUP_CALL_RING_AGE = 30 * durations.MINUTE;\n\nasync function cleanExpiredGroupCallRingCancellations(): Promise<void> {\n  const db = getInstance();\n\n  db.prepare<Query>(\n    `\n    DELETE FROM groupCallRingCancellations\n    WHERE createdAt < $expiredRingTime;\n    `\n  ).run({\n    expiredRingTime: Date.now() - MAX_GROUP_CALL_RING_AGE,\n  });\n}\n\nasync function getMaxMessageCounter(): Promise<number | undefined> {\n  const db = getInstance();\n\n  return db\n    .prepare<EmptyQuery>(\n      `\n    SELECT MAX(counter)\n    FROM\n      (\n        SELECT MAX(received_at) AS counter FROM messages\n        UNION\n        SELECT MAX(timestamp) AS counter FROM unprocessed\n      )\n    `\n    )\n    .pluck()\n    .get();\n}\n\nasync function getStatisticsForLogging(): Promise<Record<string, string>> {\n  const db = getInstance();\n  const counts = await pProps({\n    messageCount: getMessageCount(),\n    conversationCount: getConversationCount(),\n    sessionCount: getCountFromTable(db, 'sessions'),\n    senderKeyCount: getCountFromTable(db, 'senderKeys'),\n  });\n  return mapValues(counts, formatCountForLogging);\n}\n\nasync function updateAllConversationColors(\n  conversationColor?: ConversationColorType,\n  customColorData?: {\n    id: string;\n    value: CustomColorType;\n  }\n): Promise<void> {\n  const db = getInstance();\n\n  db.prepare<Query>(\n    `\n    UPDATE conversations\n    SET json = JSON_PATCH(json, $patch);\n    `\n  ).run({\n    patch: JSON.stringify({\n      conversationColor: conversationColor || null,\n      customColor: customColorData?.value || null,\n      customColorId: customColorData?.id || null,\n    }),\n  });\n}\n\nasync function removeAllProfileKeyCredentials(): Promise<void> {\n  const db = getInstance();\n\n  db.exec(\n    `\n    UPDATE conversations\n    SET\n      json = json_remove(json, '$.profileKeyCredential')\n    `\n  );\n}\n\nasync function saveEditedMessage(\n  mainMessage: MessageType,\n  ourUuid: UUIDStringType,\n  { fromId, messageId, readStatus, sentAt }: EditedMessageType\n): Promise<void> {\n  const db = getInstance();\n\n  db.transaction(() => {\n    assertSync(\n      saveMessageSync(mainMessage, {\n        ourUuid,\n        alreadyInTransaction: true,\n      })\n    );\n\n    const [query, params] = sql`\n      INSERT INTO edited_messages (\n        fromId,\n        messageId,\n        sentAt,\n        readStatus\n      ) VALUES (\n        ${fromId},\n        ${messageId},\n        ${sentAt},\n        ${readStatus}\n      );\n    `;\n\n    db.prepare(query).run(params);\n  })();\n}\n\nasync function _getAllEditedMessages(): Promise<\n  Array<{ messageId: string; sentAt: number }>\n> {\n  const db = getInstance();\n\n  return db\n    .prepare<Query>(\n      `\n      SELECT * FROM edited_messages;\n      `\n    )\n    .all({});\n}\n\nasync function getUnreadEditedMessagesAndMarkRead({\n  fromId,\n  newestUnreadAt,\n}: {\n  fromId: string;\n  newestUnreadAt: number;\n}): Promise<GetUnreadByConversationAndMarkReadResultType> {\n  const db = getInstance();\n\n  return db.transaction(() => {\n    const [selectQuery, selectParams] = sql`\n      SELECT\n        messages.id,\n        messages.json,\n        edited_messages.sentAt,\n        edited_messages.readStatus\n      FROM edited_messages\n      JOIN messages\n        ON messages.id = edited_messages.messageId\n      WHERE\n        edited_messages.readStatus = ${ReadStatus.Unread} AND\n        edited_messages.fromId = ${fromId} AND\n        received_at <= ${newestUnreadAt}\n      ORDER BY messages.received_at DESC, messages.sent_at DESC;\n    `;\n\n    const rows = db.prepare(selectQuery).all(selectParams);\n\n    if (rows.length) {\n      const newestSentAt = rows[0].sentAt;\n\n      const [updateStatusQuery, updateStatusParams] = sql`\n        UPDATE edited_messages\n          SET\n            readStatus = ${ReadStatus.Read}\n          WHERE\n            readStatus = ${ReadStatus.Unread} AND\n            fromId = ${fromId} AND\n            sentAt <= ${newestSentAt};\n      `;\n\n      db.prepare(updateStatusQuery).run(updateStatusParams);\n    }\n\n    return rows.map(row => {\n      const json = jsonToObject<MessageType>(row.json);\n      return {\n        originalReadStatus: row.readStatus,\n        readStatus: ReadStatus.Read,\n        seenStatus: SeenStatus.Seen,\n        ...pick(json, [\n          'expirationStartTimestamp',\n          'id',\n          'sent_at',\n          'source',\n          'sourceUuid',\n          'type',\n        ]),\n        // Use the edited message timestamp\n        sent_at: row.sentAt,\n      };\n    });\n  })();\n}\n","// Copyright 2021 Signal Messenger, LLC\n// SPDX-License-Identifier: AGPL-3.0-only\n\nimport type { Database } from '@signalapp/better-sqlite3';\nimport { isNumber, last } from 'lodash';\n\nexport type EmptyQuery = [];\nexport type ArrayQuery = Array<ReadonlyArray<null | number | bigint | string>>;\nexport type Query = {\n  [key: string]: null | number | bigint | string | Uint8Array;\n};\nexport type JSONRows = Array<{ readonly json: string }>;\n\nexport type TableType =\n  | 'attachment_downloads'\n  | 'conversations'\n  | 'identityKeys'\n  | 'items'\n  | 'messages'\n  | 'preKeys'\n  | 'senderKeys'\n  | 'sessions'\n  | 'signedPreKeys'\n  | 'stickers'\n  | 'unprocessed';\n\n// This value needs to be below SQLITE_MAX_VARIABLE_NUMBER.\nconst MAX_VARIABLE_COUNT = 100;\n\nexport function objectToJSON<T>(data: T): string {\n  return JSON.stringify(data);\n}\n\nexport function jsonToObject<T>(json: string): T {\n  return JSON.parse(json);\n}\n\nexport type QueryTemplateParam = string | number | undefined;\nexport type QueryFragmentValue = QueryFragment | QueryTemplateParam;\n\nexport type QueryFragment = [\n  { fragment: string },\n  ReadonlyArray<QueryTemplateParam>\n];\n\n/**\n * You can use tagged template literals to build \"fragments\" of SQL queries\n *\n * ```ts\n * const [query, params] = sql`\n *   SELECT * FROM examples\n *   WHERE groupId = ${groupId}\n *   ORDER BY timestamp ${asc ? sqlFragment`ASC` : sqlFragment`DESC`}\n * `;\n * ```\n *\n * SQL Fragments can contain other SQL fragments, but must be finalized with\n * `sql` before being passed to `Database#prepare`.\n *\n * The name `sqlFragment` comes from several editors that support SQL syntax\n * highlighting inside JavaScript template literals.\n */\nexport function sqlFragment(\n  strings: TemplateStringsArray,\n  ...values: ReadonlyArray<QueryFragmentValue>\n): QueryFragment {\n  let query = '';\n  const params: Array<string | number | undefined> = [];\n\n  strings.forEach((string, index) => {\n    const value = values[index];\n\n    query += string;\n\n    if (index < values.length) {\n      if (Array.isArray(value)) {\n        const [{ fragment }, fragmentParams] = value;\n        query += fragment;\n        params.push(...fragmentParams);\n      } else {\n        query += '?';\n        params.push(value);\n      }\n    }\n  });\n\n  return [{ fragment: query }, params];\n}\n\n/**\n * Like `Array.prototype.join`, but for SQL fragments.\n */\nexport function sqlJoin(\n  items: ReadonlyArray<QueryFragmentValue>,\n  separator: string\n): QueryFragment {\n  let query = '';\n  const params: Array<string | number | undefined> = [];\n\n  items.forEach((item, index) => {\n    const [{ fragment }, fragmentParams] = sqlFragment`${item}`;\n    query += fragment;\n    params.push(...fragmentParams);\n\n    if (index < items.length - 1) {\n      query += separator;\n    }\n  });\n\n  return [{ fragment: query }, params];\n}\n\nexport type QueryTemplate = [\n  string,\n  ReadonlyArray<string | number | undefined>\n];\n\n/**\n * You can use tagged template literals to build SQL queries\n * that can be passed to `Database#prepare`.\n *\n * ```ts\n * const [query, params] = sql`\n *   SELECT * FROM examples\n *   WHERE groupId = ${groupId}\n *   ORDER BY timestamp ASC\n * `;\n * db.prepare(query).all(params);\n * ```\n *\n * SQL queries can contain other SQL fragments, but cannot contain other SQL\n * queries.\n *\n * The name `sql` comes from several editors that support SQL syntax\n * highlighting inside JavaScript template literals.\n */\nexport function sql(\n  strings: TemplateStringsArray,\n  ...values: ReadonlyArray<QueryFragment | string | number | undefined>\n): QueryTemplate {\n  const [{ fragment }, params] = sqlFragment(strings, ...values);\n  return [fragment, params];\n}\n\ntype QueryPlanRow = Readonly<{\n  id: number;\n  parent: number;\n  details: string;\n}>;\n\ntype QueryPlan = Readonly<{\n  query: string;\n  plan: ReadonlyArray<QueryPlanRow>;\n}>;\n\n/**\n * Returns typed objects of the query plan for the given query.\n *\n *\n * ```ts\n * const [query, params] = sql`\n *   SELECT * FROM examples\n *   WHERE groupId = ${groupId}\n *   ORDER BY timestamp ASC\n * `;\n * log.info('Query plan', explainQueryPlan(db, [query, params]));\n * db.prepare(query).all(params);\n * ```\n */\nexport function explainQueryPlan(\n  db: Database,\n  template: QueryTemplate\n): QueryPlan {\n  const [query, params] = template;\n  const plan = db.prepare(`EXPLAIN QUERY PLAN ${query}`).all(params);\n  return { query, plan };\n}\n\n//\n// Database helpers\n//\n\nexport function getSQLiteVersion(db: Database): string {\n  const { sqlite_version: version } = db\n    .prepare<EmptyQuery>('select sqlite_version() AS sqlite_version')\n    .get();\n\n  return version;\n}\n\nexport function getSchemaVersion(db: Database): number {\n  return db.pragma('schema_version', { simple: true });\n}\n\nexport function setUserVersion(db: Database, version: number): void {\n  if (!isNumber(version)) {\n    throw new Error(`setUserVersion: version ${version} is not a number`);\n  }\n  db.pragma(`user_version = ${version}`);\n}\n\nexport function getUserVersion(db: Database): number {\n  return db.pragma('user_version', { simple: true });\n}\n\nexport function getSQLCipherVersion(db: Database): string | undefined {\n  return db.pragma('cipher_version', { simple: true });\n}\n\n//\n// Various table helpers\n//\n\nexport function batchMultiVarQuery<ValueT>(\n  db: Database,\n  values: ReadonlyArray<ValueT>,\n  query: (batch: ReadonlyArray<ValueT>) => void\n): [];\nexport function batchMultiVarQuery<ValueT, ResultT>(\n  db: Database,\n  values: ReadonlyArray<ValueT>,\n  query: (batch: ReadonlyArray<ValueT>) => Array<ResultT>\n): Array<ResultT>;\n\nexport function batchMultiVarQuery<ValueT, ResultT>(\n  db: Database,\n  values: ReadonlyArray<ValueT>,\n  query:\n    | ((batch: ReadonlyArray<ValueT>) => void)\n    | ((batch: ReadonlyArray<ValueT>) => Array<ResultT>)\n): Array<ResultT> {\n  if (values.length > MAX_VARIABLE_COUNT) {\n    const result: Array<ResultT> = [];\n    db.transaction(() => {\n      for (let i = 0; i < values.length; i += MAX_VARIABLE_COUNT) {\n        const batch = values.slice(i, i + MAX_VARIABLE_COUNT);\n        const batchResult = query(batch);\n        if (Array.isArray(batchResult)) {\n          result.push(...batchResult);\n        }\n      }\n    })();\n    return result;\n  }\n\n  const result = query(values);\n  return Array.isArray(result) ? result : [];\n}\n\nexport function createOrUpdate<Key extends string | number>(\n  db: Database,\n  table: TableType,\n  data: Record<string, unknown> & { id: Key }\n): void {\n  const { id } = data;\n  if (!id) {\n    throw new Error('createOrUpdate: Provided data did not have a truthy id');\n  }\n\n  db.prepare<Query>(\n    `\n    INSERT OR REPLACE INTO ${table} (\n      id,\n      json\n    ) values (\n      $id,\n      $json\n    )\n    `\n  ).run({\n    id,\n    json: objectToJSON(data),\n  });\n}\n\nexport function bulkAdd(\n  db: Database,\n  table: TableType,\n  array: Array<Record<string, unknown> & { id: string | number }>\n): void {\n  db.transaction(() => {\n    for (const data of array) {\n      createOrUpdate(db, table, data);\n    }\n  })();\n}\n\nexport function getById<Key extends string | number, Result = unknown>(\n  db: Database,\n  table: TableType,\n  id: Key\n): Result | undefined {\n  const row = db\n    .prepare<Query>(\n      `\n      SELECT *\n      FROM ${table}\n      WHERE id = $id;\n      `\n    )\n    .get({\n      id,\n    });\n\n  if (!row) {\n    return undefined;\n  }\n\n  return jsonToObject(row.json);\n}\n\nexport function removeById<Key extends string | number>(\n  db: Database,\n  table: TableType,\n  id: Key | Array<Key>\n): void {\n  if (!Array.isArray(id)) {\n    db.prepare<Query>(\n      `\n      DELETE FROM ${table}\n      WHERE id = $id;\n      `\n    ).run({ id });\n    return;\n  }\n\n  if (!id.length) {\n    throw new Error('removeById: No ids to delete!');\n  }\n\n  const removeByIdsSync = (ids: ReadonlyArray<string | number>): void => {\n    db.prepare<ArrayQuery>(\n      `\n      DELETE FROM ${table}\n      WHERE id IN ( ${id.map(() => '?').join(', ')} );\n      `\n    ).run(ids);\n  };\n\n  batchMultiVarQuery(db, id, removeByIdsSync);\n}\n\nexport function removeAllFromTable(db: Database, table: TableType): void {\n  db.prepare<EmptyQuery>(`DELETE FROM ${table};`).run();\n}\n\nexport function getAllFromTable<T>(db: Database, table: TableType): Array<T> {\n  const rows: JSONRows = db\n    .prepare<EmptyQuery>(`SELECT json FROM ${table};`)\n    .all();\n\n  return rows.map(row => jsonToObject(row.json));\n}\n\nexport function getCountFromTable(db: Database, table: TableType): number {\n  const result: null | number = db\n    .prepare<EmptyQuery>(`SELECT count(*) from ${table};`)\n    .pluck(true)\n    .get();\n  if (isNumber(result)) {\n    return result;\n  }\n  throw new Error(`getCountFromTable: Unable to get count from table ${table}`);\n}\n\nexport class TableIterator<ObjectType extends { id: string }> {\n  constructor(\n    private readonly db: Database,\n    private readonly table: TableType,\n    private readonly pageSize = 500\n  ) {}\n\n  *[Symbol.iterator](): Iterator<ObjectType> {\n    const fetchObject = this.db.prepare<Query>(\n      `\n        SELECT json FROM ${this.table}\n        WHERE id > $id\n        ORDER BY id ASC\n        LIMIT $pageSize;\n      `\n    );\n\n    let complete = false;\n    let id = '';\n    while (!complete) {\n      const rows: JSONRows = fetchObject.all({\n        id,\n        pageSize: this.pageSize,\n      });\n\n      const messages: Array<ObjectType> = rows.map(row =>\n        jsonToObject(row.json)\n      );\n      yield* messages;\n\n      const lastMessage: ObjectType | undefined = last(messages);\n      if (lastMessage) {\n        ({ id } = lastMessage);\n      }\n      complete = messages.length < this.pageSize;\n    }\n  }\n}\n"],"names":[],"sourceRoot":""}